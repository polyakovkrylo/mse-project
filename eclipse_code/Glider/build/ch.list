
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001a0 <Reset_Handler>:
 80001a0:	b672      	cpsid	i
 80001a2:	4834      	ldr	r0, [pc, #208]	; (8000274 <endfiniloop+0x4>)
 80001a4:	f380 8809 	msr	PSP, r0
 80001a8:	f240 0000 	movw	r0, #0
 80001ac:	f2cc 0000 	movt	r0, #49152	; 0xc000
 80001b0:	f64e 7134 	movw	r1, #61236	; 0xef34
 80001b4:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001b8:	6008      	str	r0, [r1, #0]
 80001ba:	f3bf 8f4f 	dsb	sy
 80001be:	f3bf 8f6f 	isb	sy
 80001c2:	f240 0000 	movw	r0, #0
 80001c6:	f2c0 00f0 	movt	r0, #240	; 0xf0
 80001ca:	f64e 5188 	movw	r1, #60808	; 0xed88
 80001ce:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001d2:	6008      	str	r0, [r1, #0]
 80001d4:	f3bf 8f4f 	dsb	sy
 80001d8:	f3bf 8f6f 	isb	sy
 80001dc:	f04f 0000 	mov.w	r0, #0
 80001e0:	eee1 0a10 	vmsr	fpscr, r0
 80001e4:	f64e 713c 	movw	r1, #61244	; 0xef3c
 80001e8:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001ec:	6008      	str	r0, [r1, #0]
 80001ee:	2006      	movs	r0, #6
 80001f0:	f380 8814 	msr	CONTROL, r0
 80001f4:	f3bf 8f6f 	isb	sy
 80001f8:	f000 ff9a 	bl	8001130 <__core_init>
 80001fc:	f001 fd50 	bl	8001ca0 <__early_init>
 8000200:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 8000204:	491c      	ldr	r1, [pc, #112]	; (8000278 <endfiniloop+0x8>)
 8000206:	4a1d      	ldr	r2, [pc, #116]	; (800027c <endfiniloop+0xc>)

08000208 <msloop>:
 8000208:	4291      	cmp	r1, r2
 800020a:	bf3c      	itt	cc
 800020c:	f841 0b04 	strcc.w	r0, [r1], #4
 8000210:	e7fa      	bcc.n	8000208 <msloop>
 8000212:	491b      	ldr	r1, [pc, #108]	; (8000280 <endfiniloop+0x10>)
 8000214:	4a17      	ldr	r2, [pc, #92]	; (8000274 <endfiniloop+0x4>)

08000216 <psloop>:
 8000216:	4291      	cmp	r1, r2
 8000218:	bf3c      	itt	cc
 800021a:	f841 0b04 	strcc.w	r0, [r1], #4
 800021e:	e7fa      	bcc.n	8000216 <psloop>
 8000220:	4918      	ldr	r1, [pc, #96]	; (8000284 <endfiniloop+0x14>)
 8000222:	4a19      	ldr	r2, [pc, #100]	; (8000288 <endfiniloop+0x18>)
 8000224:	4b19      	ldr	r3, [pc, #100]	; (800028c <endfiniloop+0x1c>)

08000226 <dloop>:
 8000226:	429a      	cmp	r2, r3
 8000228:	bf3e      	ittt	cc
 800022a:	f851 0b04 	ldrcc.w	r0, [r1], #4
 800022e:	f842 0b04 	strcc.w	r0, [r2], #4
 8000232:	e7f8      	bcc.n	8000226 <dloop>
 8000234:	2000      	movs	r0, #0
 8000236:	4916      	ldr	r1, [pc, #88]	; (8000290 <endfiniloop+0x20>)
 8000238:	4a16      	ldr	r2, [pc, #88]	; (8000294 <endfiniloop+0x24>)

0800023a <bloop>:
 800023a:	4291      	cmp	r1, r2
 800023c:	bf3c      	itt	cc
 800023e:	f841 0b04 	strcc.w	r0, [r1], #4
 8000242:	e7fa      	bcc.n	800023a <bloop>
 8000244:	f000 ff2c 	bl	80010a0 <__init_ram_areas>
 8000248:	f000 ff6a 	bl	8001120 <__late_init>
 800024c:	4c12      	ldr	r4, [pc, #72]	; (8000298 <endfiniloop+0x28>)
 800024e:	4d13      	ldr	r5, [pc, #76]	; (800029c <endfiniloop+0x2c>)

08000250 <initloop>:
 8000250:	42ac      	cmp	r4, r5
 8000252:	da03      	bge.n	800025c <endinitloop>
 8000254:	f854 1b04 	ldr.w	r1, [r4], #4
 8000258:	4788      	blx	r1
 800025a:	e7f9      	b.n	8000250 <initloop>

0800025c <endinitloop>:
 800025c:	f001 ff10 	bl	8002080 <main>
 8000260:	4c0f      	ldr	r4, [pc, #60]	; (80002a0 <endfiniloop+0x30>)
 8000262:	4d10      	ldr	r5, [pc, #64]	; (80002a4 <endfiniloop+0x34>)

08000264 <finiloop>:
 8000264:	42ac      	cmp	r4, r5
 8000266:	da03      	bge.n	8000270 <endfiniloop>
 8000268:	f854 1b04 	ldr.w	r1, [r4], #4
 800026c:	4788      	blx	r1
 800026e:	e7f9      	b.n	8000264 <finiloop>

08000270 <endfiniloop>:
 8000270:	f000 bf4e 	b.w	8001110 <__default_exit>
 8000274:	20000800 	.word	0x20000800
 8000278:	20000000 	.word	0x20000000
 800027c:	20000400 	.word	0x20000400
 8000280:	20000400 	.word	0x20000400
 8000284:	08002dd8 	.word	0x08002dd8
 8000288:	20000800 	.word	0x20000800
 800028c:	20000804 	.word	0x20000804
 8000290:	20000808 	.word	0x20000808
 8000294:	20001388 	.word	0x20001388
 8000298:	080001a0 	.word	0x080001a0
 800029c:	080001a0 	.word	0x080001a0
 80002a0:	080001a0 	.word	0x080001a0
 80002a4:	080001a0 	.word	0x080001a0
	...

080002b0 <_port_switch>:
 80002b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002b4:	ed2d 8a10 	vpush	{s16-s31}
 80002b8:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002bc:	68c3      	ldr	r3, [r0, #12]
 80002be:	469d      	mov	sp, r3
 80002c0:	ecbd 8a10 	vpop	{s16-s31}
 80002c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002c8 <_port_thread_start>:
 80002c8:	2300      	movs	r3, #0
 80002ca:	f383 8811 	msr	BASEPRI, r3
 80002ce:	4628      	mov	r0, r5
 80002d0:	47a0      	blx	r4
 80002d2:	2000      	movs	r0, #0
 80002d4:	f000 feb4 	bl	8001040 <chThdExit>

080002d8 <_port_switch_from_isr>:
 80002d8:	f000 fca2 	bl	8000c20 <chSchDoReschedule>

080002dc <_port_exit_from_isr>:
 80002dc:	df00      	svc	0
 80002de:	e7fe      	b.n	80002de <_port_exit_from_isr+0x2>

080002e0 <set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 80002e0:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
  usb_lld_set_address(usbp);
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80002e4:	6842      	ldr	r2, [r0, #4]
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 80002e6:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {

  STM32_USB->DADDR = (uint32_t)(usbp->address) | DADDR_EF;
 80002ea:	4906      	ldr	r1, [pc, #24]	; (8000304 <set_address+0x24>)
  usb_lld_set_address(usbp);
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80002ec:	6812      	ldr	r2, [r2, #0]
 80002ee:	f043 0380 	orr.w	r3, r3, #128	; 0x80
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 80002f2:	b510      	push	{r4, lr}
 80002f4:	4604      	mov	r4, r0
 80002f6:	64cb      	str	r3, [r1, #76]	; 0x4c

  usbp->address = usbp->setup[2];
  usb_lld_set_address(usbp);
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80002f8:	b10a      	cbz	r2, 80002fe <set_address+0x1e>
 80002fa:	2101      	movs	r1, #1
 80002fc:	4790      	blx	r2
  usbp->state = USB_SELECTED;
 80002fe:	2303      	movs	r3, #3
 8000300:	7023      	strb	r3, [r4, #0]
 8000302:	bd10      	pop	{r4, pc}
 8000304:	40005c00 	.word	0x40005c00
	...

08000310 <SVC_Handler>:
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8000310:	4a06      	ldr	r2, [pc, #24]	; (800032c <SVC_Handler+0x1c>)
 8000312:	6853      	ldr	r3, [r2, #4]
 8000314:	f023 0301 	bic.w	r3, r3, #1
 8000318:	6053      	str	r3, [r2, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800031a:	f3ef 8309 	mrs	r3, PSP

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800031e:	3368      	adds	r3, #104	; 0x68
 8000320:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000324:	2300      	movs	r3, #0
 8000326:	f383 8811 	msr	BASEPRI, r3
 800032a:	4770      	bx	lr
 800032c:	e000ef30 	.word	0xe000ef30

08000330 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8000330:	b410      	push	{r4}
 8000332:	2320      	movs	r3, #32
 8000334:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000338:	4c09      	ldr	r4, [pc, #36]	; (8000360 <chCoreAlloc+0x30>)
 800033a:	4b0a      	ldr	r3, [pc, #40]	; (8000364 <chCoreAlloc+0x34>)
 800033c:	6822      	ldr	r2, [r4, #0]
 800033e:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8000340:	1dc3      	adds	r3, r0, #7
 8000342:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000346:	1a89      	subs	r1, r1, r2
 8000348:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 800034a:	bf9d      	ittte	ls
 800034c:	189b      	addls	r3, r3, r2
 800034e:	6023      	strls	r3, [r4, #0]

  return p;
 8000350:	4610      	movls	r0, r2

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 8000352:	2000      	movhi	r0, #0
 8000354:	2300      	movs	r3, #0
 8000356:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 800035a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800035e:	4770      	bx	lr
 8000360:	20000ad4 	.word	0x20000ad4
 8000364:	20000ad0 	.word	0x20000ad0
	...

08000370 <wakeup.lto_priv.46>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000370:	b410      	push	{r4}
 8000372:	2320      	movs	r3, #32
 8000374:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8000378:	7f03      	ldrb	r3, [r0, #28]
 800037a:	2b07      	cmp	r3, #7
 800037c:	d80e      	bhi.n	800039c <wakeup.lto_priv.46+0x2c>
 800037e:	e8df f003 	tbb	[pc, r3]
 8000382:	0d27      	.short	0x0d27
 8000384:	0408230d 	.word	0x0408230d
 8000388:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 800038a:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800038c:	6893      	ldr	r3, [r2, #8]
 800038e:	3301      	adds	r3, #1
 8000390:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000392:	e890 000c 	ldmia.w	r0, {r2, r3}
 8000396:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000398:	6802      	ldr	r2, [r0, #0]
 800039a:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800039c:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80003a0:	2200      	movs	r2, #0
 80003a2:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 80003a4:	4b0d      	ldr	r3, [pc, #52]	; (80003dc <wakeup.lto_priv.46+0x6c>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80003a6:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80003a8:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 80003aa:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80003ac:	689a      	ldr	r2, [r3, #8]
 80003ae:	428a      	cmp	r2, r1
 80003b0:	d2fb      	bcs.n	80003aa <wakeup.lto_priv.46+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80003b2:	685a      	ldr	r2, [r3, #4]
 80003b4:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80003b6:	6003      	str	r3, [r0, #0]
 80003b8:	2100      	movs	r1, #0
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80003ba:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 80003bc:	6058      	str	r0, [r3, #4]
 80003be:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80003c2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80003c6:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 80003c8:	6a03      	ldr	r3, [r0, #32]
 80003ca:	2200      	movs	r2, #0
 80003cc:	601a      	str	r2, [r3, #0]
 80003ce:	e7e5      	b.n	800039c <wakeup.lto_priv.46+0x2c>
 80003d0:	2300      	movs	r3, #0
 80003d2:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80003d6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80003da:	4770      	bx	lr
 80003dc:	20001178 	.word	0x20001178

080003e0 <_idle_thread.lto_priv.47>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80003e0:	e7fe      	b.n	80003e0 <_idle_thread.lto_priv.47>
 80003e2:	bf00      	nop
	...

080003f0 <_usb_ep0out>:
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {

  (void)ep;
  switch (usbp->ep0state) {
 80003f0:	f890 2064 	ldrb.w	r2, [r0, #100]	; 0x64
 80003f4:	2a06      	cmp	r2, #6
 80003f6:	d80c      	bhi.n	8000412 <_usb_ep0out+0x22>
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 80003f8:	b538      	push	{r3, r4, r5, lr}
 80003fa:	2301      	movs	r3, #1
 80003fc:	4093      	lsls	r3, r2
 80003fe:	f013 0f67 	tst.w	r3, #103	; 0x67
 8000402:	4604      	mov	r4, r0
 8000404:	d112      	bne.n	800042c <_usb_ep0out+0x3c>
 8000406:	f013 0508 	ands.w	r5, r3, #8
 800040a:	d103      	bne.n	8000414 <_usb_ep0out+0x24>
 800040c:	06db      	lsls	r3, r3, #27
 800040e:	d42f      	bmi.n	8000470 <_usb_ep0out+0x80>
 8000410:	bd38      	pop	{r3, r4, r5, pc}
 8000412:	4770      	bx	lr
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8000414:	68c3      	ldr	r3, [r0, #12]
 8000416:	699b      	ldr	r3, [r3, #24]
 8000418:	685b      	ldr	r3, [r3, #4]
 800041a:	2b00      	cmp	r3, #0
 800041c:	d1f8      	bne.n	8000410 <_usb_ep0out+0x20>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800041e:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8000420:	b103      	cbz	r3, 8000424 <_usb_ep0out+0x34>
      usbp->ep0endcb(usbp);
 8000422:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8000424:	2300      	movs	r3, #0
 8000426:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800042a:	bd38      	pop	{r3, r4, r5, pc}
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 800042c:	491a      	ldr	r1, [pc, #104]	; (8000498 <_usb_ep0out+0xa8>)
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800042e:	6842      	ldr	r2, [r0, #4]
 8000430:	680b      	ldr	r3, [r1, #0]
 8000432:	6812      	ldr	r2, [r2, #0]
 8000434:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8000438:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800043c:	f083 0310 	eor.w	r3, r3, #16
 8000440:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000444:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000448:	600b      	str	r3, [r1, #0]
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 800044a:	680b      	ldr	r3, [r1, #0]
 800044c:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8000450:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8000454:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8000458:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800045c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000460:	600b      	str	r3, [r1, #0]
 8000462:	b10a      	cbz	r2, 8000468 <_usb_ep0out+0x78>
 8000464:	2106      	movs	r1, #6
 8000466:	4790      	blx	r2
    usbp->ep0state = USB_EP0_ERROR;
 8000468:	2306      	movs	r3, #6
 800046a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800046e:	bd38      	pop	{r3, r4, r5, pc}

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 8000470:	2305      	movs	r3, #5
 8000472:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
 8000476:	2320      	movs	r3, #32
 8000478:	f383 8811 	msr	BASEPRI, r3
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 800047c:	68c3      	ldr	r3, [r0, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800047e:	8902      	ldrh	r2, [r0, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8000480:	695b      	ldr	r3, [r3, #20]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000482:	f042 0201 	orr.w	r2, r2, #1
 8000486:	8102      	strh	r2, [r0, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
 8000488:	609d      	str	r5, [r3, #8]
  isp->txsize = n;
 800048a:	601d      	str	r5, [r3, #0]
  isp->txcnt  = 0;
 800048c:	605d      	str	r5, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 800048e:	f002 fb37 	bl	8002b00 <usb_lld_start_in.constprop.10>
 8000492:	f385 8811 	msr	BASEPRI, r5
 8000496:	bd38      	pop	{r3, r4, r5, pc}
 8000498:	40005c00 	.word	0x40005c00
 800049c:	00000000 	.word	0x00000000

080004a0 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 80004a0:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 80004a2:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 80004a6:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 80004a8:	2b06      	cmp	r3, #6
 80004aa:	d826      	bhi.n	80004fa <_usb_ep0in+0x5a>
 80004ac:	e8df f003 	tbb	[pc, r3]
 80004b0:	04362604 	.word	0x04362604
 80004b4:	4c04      	.short	0x4c04
 80004b6:	04          	.byte	0x04
 80004b7:	00          	.byte	0x00
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 80004b8:	4931      	ldr	r1, [pc, #196]	; (8000580 <_usb_ep0in+0xe0>)
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80004ba:	6842      	ldr	r2, [r0, #4]
 80004bc:	680b      	ldr	r3, [r1, #0]
 80004be:	6812      	ldr	r2, [r2, #0]
 80004c0:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 80004c4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80004c8:	f083 0310 	eor.w	r3, r3, #16
 80004cc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80004d0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80004d4:	600b      	str	r3, [r1, #0]
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 80004d6:	680b      	ldr	r3, [r1, #0]
 80004d8:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 80004dc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80004e0:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 80004e4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80004e8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80004ec:	600b      	str	r3, [r1, #0]
 80004ee:	b10a      	cbz	r2, 80004f4 <_usb_ep0in+0x54>
 80004f0:	2106      	movs	r1, #6
 80004f2:	4790      	blx	r2
    usbp->ep0state = USB_EP0_ERROR;
 80004f4:	2306      	movs	r3, #6
 80004f6:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80004fa:	bd38      	pop	{r3, r4, r5, pc}
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80004fc:	f890 107b 	ldrb.w	r1, [r0, #123]	; 0x7b
 8000500:	f890 307a 	ldrb.w	r3, [r0, #122]	; 0x7a
 8000504:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8000506:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800050a:	4293      	cmp	r3, r2
 800050c:	d906      	bls.n	800051c <_usb_ep0in+0x7c>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 800050e:	68c3      	ldr	r3, [r0, #12]
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8000510:	8a1d      	ldrh	r5, [r3, #16]
 8000512:	fbb2 f3f5 	udiv	r3, r2, r5
 8000516:	fb05 2513 	mls	r5, r5, r3, r2
 800051a:	b1e5      	cbz	r5, 8000556 <_usb_ep0in+0xb6>
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 800051c:	2303      	movs	r3, #3
 800051e:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8000522:	2320      	movs	r3, #32
 8000524:	f383 8811 	msr	BASEPRI, r3
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8000528:	68e3      	ldr	r3, [r4, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800052a:	8962      	ldrh	r2, [r4, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 800052c:	699b      	ldr	r3, [r3, #24]
  /*lint -restore*/
  osp->rxbuf  = buf;
 800052e:	2500      	movs	r5, #0
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000530:	f042 0201 	orr.w	r2, r2, #1
 8000534:	8162      	strh	r2, [r4, #10]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8000536:	4620      	mov	r0, r4

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
 8000538:	609d      	str	r5, [r3, #8]
  osp->rxsize = n;
 800053a:	601d      	str	r5, [r3, #0]
  osp->rxcnt  = 0;
 800053c:	605d      	str	r5, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 800053e:	f002 fb17 	bl	8002b70 <usb_lld_start_out.constprop.9>
 8000542:	f385 8811 	msr	BASEPRI, r5
 8000546:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8000548:	6f03      	ldr	r3, [r0, #112]	; 0x70
 800054a:	b103      	cbz	r3, 800054e <_usb_ep0in+0xae>
      usbp->ep0endcb(usbp);
 800054c:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 800054e:	2300      	movs	r3, #0
 8000550:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8000554:	bd38      	pop	{r3, r4, r5, pc}
 8000556:	2320      	movs	r3, #32
 8000558:	f383 8811 	msr	BASEPRI, r3
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 800055c:	68c3      	ldr	r3, [r0, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800055e:	8902      	ldrh	r2, [r0, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8000560:	695b      	ldr	r3, [r3, #20]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000562:	f042 0201 	orr.w	r2, r2, #1
 8000566:	8102      	strh	r2, [r0, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
 8000568:	609d      	str	r5, [r3, #8]
  isp->txsize = n;
 800056a:	601d      	str	r5, [r3, #0]
  isp->txcnt  = 0;
 800056c:	605d      	str	r5, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 800056e:	f002 fac7 	bl	8002b00 <usb_lld_start_in.constprop.10>
 8000572:	f385 8811 	msr	BASEPRI, r5
    if ((usbp->ep0n < max) &&
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, NULL, 0);
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8000576:	2302      	movs	r3, #2
 8000578:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800057c:	bd38      	pop	{r3, r4, r5, pc}
 800057e:	bf00      	nop
 8000580:	40005c00 	.word	0x40005c00
	...

08000590 <_usb_ep0setup>:
  stm32_usb_pma_t *pmap;
  stm32_usb_descriptor_t *udp;
  uint32_t n;

  (void)usbp;
  udp = USB_GET_DESCRIPTOR(ep);
 8000590:	4bb2      	ldr	r3, [pc, #712]	; (800085c <_usb_ep0setup+0x2cc>)
 8000592:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8000594:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8000598:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 800059c:	eb03 1101 	add.w	r1, r3, r1, lsl #4
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80005a0:	b570      	push	{r4, r5, r6, lr}
  pmap = USB_ADDR2PTR(udp->RXADDR0);
 80005a2:	688b      	ldr	r3, [r1, #8]
 80005a4:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 80005a8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80005ac:	4604      	mov	r4, r0
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80005ae:	2200      	movs	r2, #0
 80005b0:	005b      	lsls	r3, r3, #1
 80005b2:	f880 2064 	strb.w	r2, [r0, #100]	; 0x64
 80005b6:	f103 0010 	add.w	r0, r3, #16
  usbReadSetup(usbp, ep, usbp->setup);
 80005ba:	f104 0274 	add.w	r2, r4, #116	; 0x74
  for (n = 0; n < 4; n++) {
    *(uint16_t *)buf = (uint16_t)*pmap++;
 80005be:	f853 1b04 	ldr.w	r1, [r3], #4
 80005c2:	f822 1b02 	strh.w	r1, [r2], #2
  uint32_t n;

  (void)usbp;
  udp = USB_GET_DESCRIPTOR(ep);
  pmap = USB_ADDR2PTR(udp->RXADDR0);
  for (n = 0; n < 4; n++) {
 80005c6:	4283      	cmp	r3, r0
 80005c8:	d1f9      	bne.n	80005be <_usb_ep0setup+0x2e>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80005ca:	6863      	ldr	r3, [r4, #4]
 80005cc:	689b      	ldr	r3, [r3, #8]
 80005ce:	b353      	cbz	r3, 8000626 <_usb_ep0setup+0x96>
      !(usbp->config->requests_hook_cb(usbp))) {
 80005d0:	4620      	mov	r0, r4
 80005d2:	4798      	blx	r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80005d4:	b338      	cbz	r0, 8000626 <_usb_ep0setup+0x96>
 80005d6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80005d8:	f894 0074 	ldrb.w	r0, [r4, #116]	; 0x74
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 80005dc:	f894 107b 	ldrb.w	r1, [r4, #123]	; 0x7b
 80005e0:	f894 207a 	ldrb.w	r2, [r4, #122]	; 0x7a
 80005e4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 80005e8:	429a      	cmp	r2, r3
    usbp->ep0n = max;
 80005ea:	bf3c      	itt	cc
 80005ec:	66e2      	strcc	r2, [r4, #108]	; 0x6c
 80005ee:	4613      	movcc	r3, r2
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80005f0:	0602      	lsls	r2, r0, #24
 80005f2:	f100 80af 	bmi.w	8000754 <_usb_ep0setup+0x1c4>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 80005f6:	2b00      	cmp	r3, #0
 80005f8:	d161      	bne.n	80006be <_usb_ep0setup+0x12e>
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 80005fa:	2305      	movs	r3, #5
 80005fc:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8000600:	2320      	movs	r3, #32
 8000602:	f383 8811 	msr	BASEPRI, r3
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8000606:	68e3      	ldr	r3, [r4, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000608:	8922      	ldrh	r2, [r4, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 800060a:	695b      	ldr	r3, [r3, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 800060c:	2500      	movs	r5, #0
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800060e:	f042 0201 	orr.w	r2, r2, #1
 8000612:	8122      	strh	r2, [r4, #8]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8000614:	4620      	mov	r0, r4

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
 8000616:	609d      	str	r5, [r3, #8]
  isp->txsize = n;
 8000618:	601d      	str	r5, [r3, #0]
  isp->txcnt  = 0;
 800061a:	605d      	str	r5, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 800061c:	f002 fa70 	bl	8002b00 <usb_lld_start_in.constprop.10>
 8000620:	f385 8811 	msr	BASEPRI, r5
 8000624:	bd70      	pop	{r4, r5, r6, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8000626:	f894 0074 	ldrb.w	r0, [r4, #116]	; 0x74
 800062a:	f010 0560 	ands.w	r5, r0, #96	; 0x60
 800062e:	4602      	mov	r2, r0
 8000630:	d022      	beq.n	8000678 <_usb_ep0setup+0xe8>
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8000632:	498a      	ldr	r1, [pc, #552]	; (800085c <_usb_ep0setup+0x2cc>)
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
      usb_lld_stall_out(usbp, 0);
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8000634:	6862      	ldr	r2, [r4, #4]
 8000636:	680b      	ldr	r3, [r1, #0]
 8000638:	6812      	ldr	r2, [r2, #0]
 800063a:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 800063e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000642:	f083 0310 	eor.w	r3, r3, #16
 8000646:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800064a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800064e:	600b      	str	r3, [r1, #0]
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8000650:	680b      	ldr	r3, [r1, #0]
 8000652:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8000656:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800065a:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 800065e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000662:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000666:	600b      	str	r3, [r1, #0]
 8000668:	b112      	cbz	r2, 8000670 <_usb_ep0setup+0xe0>
 800066a:	2106      	movs	r1, #6
 800066c:	4620      	mov	r0, r4
 800066e:	4790      	blx	r2
      usbp->ep0state = USB_EP0_ERROR;
 8000670:	2306      	movs	r3, #6
 8000672:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8000676:	bd70      	pop	{r4, r5, r6, pc}
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
 8000678:	f894 1075 	ldrb.w	r1, [r4, #117]	; 0x75
 800067c:	f000 037f 	and.w	r3, r0, #127	; 0x7f
 8000680:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8000684:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8000688:	f000 8165 	beq.w	8000956 <_usb_ep0setup+0x3c6>
 800068c:	d92e      	bls.n	80006ec <_usb_ep0setup+0x15c>
 800068e:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8000692:	f000 8147 	beq.w	8000924 <_usb_ep0setup+0x394>
 8000696:	d975      	bls.n	8000784 <_usb_ep0setup+0x1f4>
 8000698:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 800069c:	f000 8097 	beq.w	80007ce <_usb_ep0setup+0x23e>
 80006a0:	f640 4202 	movw	r2, #3074	; 0xc02
 80006a4:	4293      	cmp	r3, r2
 80006a6:	f000 8136 	beq.w	8000916 <_usb_ep0setup+0x386>
 80006aa:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80006ae:	d1c0      	bne.n	8000632 <_usb_ep0setup+0xa2>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 80006b0:	f104 027f 	add.w	r2, r4, #127	; 0x7f
 80006b4:	2301      	movs	r3, #1
 80006b6:	6725      	str	r5, [r4, #112]	; 0x70
 80006b8:	66a2      	str	r2, [r4, #104]	; 0x68
 80006ba:	66e3      	str	r3, [r4, #108]	; 0x6c
 80006bc:	e78e      	b.n	80005dc <_usb_ep0setup+0x4c>
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 80006be:	2304      	movs	r3, #4
 80006c0:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80006c4:	2320      	movs	r3, #32
 80006c6:	f383 8811 	msr	BASEPRI, r3
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 80006ca:	68e3      	ldr	r3, [r4, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80006cc:	8962      	ldrh	r2, [r4, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 80006ce:	699b      	ldr	r3, [r3, #24]
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80006d0:	6ea6      	ldr	r6, [r4, #104]	; 0x68
 80006d2:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80006d4:	f042 0201 	orr.w	r2, r2, #1
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
  osp->rxsize = n;
  osp->rxcnt  = 0;
 80006d8:	2500      	movs	r5, #0
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80006da:	8162      	strh	r2, [r4, #10]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 80006dc:	4620      	mov	r0, r4
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
  osp->rxsize = n;
  osp->rxcnt  = 0;
 80006de:	e883 0062 	stmia.w	r3, {r1, r5, r6}
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 80006e2:	f002 fa45 	bl	8002b70 <usb_lld_start_out.constprop.9>
 80006e6:	f385 8811 	msr	BASEPRI, r5
 80006ea:	bd70      	pop	{r4, r5, r6, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80006ec:	2b02      	cmp	r3, #2
 80006ee:	f000 80f9 	beq.w	80008e4 <_usb_ep0setup+0x354>
 80006f2:	f240 80ee 	bls.w	80008d2 <_usb_ep0setup+0x342>
 80006f6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80006fa:	d07e      	beq.n	80007fa <_usb_ep0setup+0x26a>
 80006fc:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8000700:	d197      	bne.n	8000632 <_usb_ep0setup+0xa2>
        return false;
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8000702:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8000706:	2b00      	cmp	r3, #0
 8000708:	d193      	bne.n	8000632 <_usb_ep0setup+0xa2>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800070a:	f894 1078 	ldrb.w	r1, [r4, #120]	; 0x78
 800070e:	f011 030f 	ands.w	r3, r1, #15
 8000712:	d01a      	beq.n	800074a <_usb_ep0setup+0x1ba>
 8000714:	009b      	lsls	r3, r3, #2
 8000716:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800071a:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800071e:	f011 0f80 	tst.w	r1, #128	; 0x80

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 8000722:	6819      	ldr	r1, [r3, #0]
 8000724:	f040 8131 	bne.w	800098a <_usb_ep0setup+0x3fa>

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) != EPR_STAT_RX_VALID)
 8000728:	f401 5140 	and.w	r1, r1, #12288	; 0x3000
 800072c:	f5b1 5f40 	cmp.w	r1, #12288	; 0x3000
 8000730:	d00b      	beq.n	800074a <_usb_ep0setup+0x1ba>
    EPR_SET_STAT_TX(ep, EPR_STAT_RX_NAK);
 8000732:	681a      	ldr	r2, [r3, #0]
 8000734:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 8000738:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800073c:	f442 4220 	orr.w	r2, r2, #40960	; 0xa000
 8000740:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000744:	601a      	str	r2, [r3, #0]
 8000746:	f894 2074 	ldrb.w	r2, [r4, #116]	; 0x74
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800074a:	2300      	movs	r3, #0
 800074c:	66a3      	str	r3, [r4, #104]	; 0x68
 800074e:	66e3      	str	r3, [r4, #108]	; 0x6c
 8000750:	6723      	str	r3, [r4, #112]	; 0x70
 8000752:	e023      	b.n	800079c <_usb_ep0setup+0x20c>
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 8000754:	b32b      	cbz	r3, 80007a2 <_usb_ep0setup+0x212>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 8000756:	2301      	movs	r3, #1
 8000758:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800075c:	2320      	movs	r3, #32
 800075e:	f383 8811 	msr	BASEPRI, r3
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8000762:	68e3      	ldr	r3, [r4, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000764:	8922      	ldrh	r2, [r4, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8000766:	695b      	ldr	r3, [r3, #20]
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8000768:	6ea6      	ldr	r6, [r4, #104]	; 0x68
 800076a:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800076c:	f042 0201 	orr.w	r2, r2, #1
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
  isp->txsize = n;
  isp->txcnt  = 0;
 8000770:	2500      	movs	r5, #0
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000772:	8122      	strh	r2, [r4, #8]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8000774:	4620      	mov	r0, r4
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
  isp->txsize = n;
  isp->txcnt  = 0;
 8000776:	e883 0062 	stmia.w	r3, {r1, r5, r6}
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 800077a:	f002 f9c1 	bl	8002b00 <usb_lld_start_in.constprop.10>
 800077e:	f385 8811 	msr	BASEPRI, r5
 8000782:	bd70      	pop	{r4, r5, r6, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8000784:	f240 3102 	movw	r1, #770	; 0x302
 8000788:	428b      	cmp	r3, r1
 800078a:	d045      	beq.n	8000818 <_usb_ep0setup+0x288>
 800078c:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8000790:	f47f af4f 	bne.w	8000632 <_usb_ep0setup+0xa2>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
      set_address(usbp);
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
 8000794:	4b32      	ldr	r3, [pc, #200]	; (8000860 <_usb_ep0setup+0x2d0>)
 8000796:	66a5      	str	r5, [r4, #104]	; 0x68
 8000798:	66e5      	str	r5, [r4, #108]	; 0x6c
 800079a:	6723      	str	r3, [r4, #112]	; 0x70
  max = (size_t)get_hword(&usbp->setup[6]);
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800079c:	0613      	lsls	r3, r2, #24
 800079e:	f57f af2c 	bpl.w	80005fa <_usb_ep0setup+0x6a>
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 80007a2:	2303      	movs	r3, #3
 80007a4:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80007a8:	2320      	movs	r3, #32
 80007aa:	f383 8811 	msr	BASEPRI, r3
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 80007ae:	68e3      	ldr	r3, [r4, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80007b0:	8962      	ldrh	r2, [r4, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 80007b2:	699b      	ldr	r3, [r3, #24]
  /*lint -restore*/
  osp->rxbuf  = buf;
 80007b4:	2500      	movs	r5, #0
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80007b6:	f042 0201 	orr.w	r2, r2, #1
 80007ba:	8162      	strh	r2, [r4, #10]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 80007bc:	4620      	mov	r0, r4

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
 80007be:	609d      	str	r5, [r3, #8]
  osp->rxsize = n;
 80007c0:	601d      	str	r5, [r3, #0]
  osp->rxcnt  = 0;
 80007c2:	605d      	str	r5, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 80007c4:	f002 f9d4 	bl	8002b70 <usb_lld_start_out.constprop.9>
 80007c8:	f385 8811 	msr	BASEPRI, r5
 80007cc:	bd70      	pop	{r4, r5, r6, pc}
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host only if it is different
       from the current configuration.*/
    if (usbp->configuration != usbp->setup[2]) {
 80007ce:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 80007d2:	f894 107f 	ldrb.w	r1, [r4, #127]	; 0x7f
 80007d6:	4299      	cmp	r1, r3
 80007d8:	d0b7      	beq.n	800074a <_usb_ep0setup+0x1ba>
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 80007da:	7822      	ldrb	r2, [r4, #0]
 80007dc:	2a04      	cmp	r2, #4
 80007de:	d041      	beq.n	8000864 <_usb_ep0setup+0x2d4>
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
 80007e0:	2b00      	cmp	r3, #0
 80007e2:	d037      	beq.n	8000854 <_usb_ep0setup+0x2c4>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 80007e4:	6862      	ldr	r2, [r4, #4]
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 80007e6:	f884 307f 	strb.w	r3, [r4, #127]	; 0x7f
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 80007ea:	6813      	ldr	r3, [r2, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
 80007ec:	2204      	movs	r2, #4
 80007ee:	7022      	strb	r2, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 80007f0:	b383      	cbz	r3, 8000854 <_usb_ep0setup+0x2c4>
 80007f2:	2102      	movs	r1, #2
 80007f4:	4620      	mov	r0, r4
 80007f6:	4798      	blx	r3
 80007f8:	e02c      	b.n	8000854 <_usb_ep0setup+0x2c4>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80007fa:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 80007fe:	2b01      	cmp	r3, #1
 8000800:	f47f af17 	bne.w	8000632 <_usb_ep0setup+0xa2>
      usbp->status &= ~2U;
 8000804:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8000808:	66a5      	str	r5, [r4, #104]	; 0x68
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 800080a:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800080e:	66e5      	str	r5, [r4, #108]	; 0x6c
 8000810:	6725      	str	r5, [r4, #112]	; 0x70
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 8000812:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
 8000816:	e7c1      	b.n	800079c <_usb_ep0setup+0x20c>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8000818:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 800081c:	2b00      	cmp	r3, #0
 800081e:	f47f af08 	bne.w	8000632 <_usb_ep0setup+0xa2>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8000822:	f894 1078 	ldrb.w	r1, [r4, #120]	; 0x78
 8000826:	f011 030f 	ands.w	r3, r1, #15
 800082a:	d08e      	beq.n	800074a <_usb_ep0setup+0x1ba>
 800082c:	009b      	lsls	r3, r3, #2
 800082e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8000832:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8000836:	0609      	lsls	r1, r1, #24
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8000838:	681a      	ldr	r2, [r3, #0]
 800083a:	f100 80ba 	bmi.w	80009b2 <_usb_ep0setup+0x422>
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 800083e:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8000842:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8000846:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
 800084a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800084e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000852:	601a      	str	r2, [r3, #0]
 8000854:	f894 2074 	ldrb.w	r2, [r4, #116]	; 0x74
 8000858:	e777      	b.n	800074a <_usb_ep0setup+0x1ba>
 800085a:	bf00      	nop
 800085c:	40005c00 	.word	0x40005c00
 8000860:	080002e1 	.word	0x080002e1
 8000864:	2320      	movs	r3, #32
 8000866:	f383 8811 	msr	BASEPRI, r3

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 800086a:	8922      	ldrh	r2, [r4, #8]
  usbp->receiving    &= 1U;
 800086c:	8963      	ldrh	r3, [r4, #10]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 800086e:	f002 0201 	and.w	r2, r2, #1
  usbp->receiving    &= 1U;
 8000872:	f003 0301 	and.w	r3, r3, #1

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8000876:	8122      	strh	r2, [r4, #8]
  usbp->receiving    &= 1U;
 8000878:	8163      	strh	r3, [r4, #10]
 800087a:	f104 0228 	add.w	r2, r4, #40	; 0x28
 800087e:	f104 030c 	add.w	r3, r4, #12
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 8000882:	f843 5f04 	str.w	r5, [r3, #4]!
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
  usbp->receiving    &= 1U;

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8000886:	4293      	cmp	r3, r2
 8000888:	d1fb      	bne.n	8000882 <_usb_ep0setup+0x2f2>
 */
static void usb_pm_reset(USBDriver *usbp) {

  /* The first 64 bytes are reserved for the descriptors table. The effective
     available RAM for endpoint buffers is just 448 bytes.*/
  usbp->pmnext = 64;
 800088a:	2340      	movs	r3, #64	; 0x40
 800088c:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8000890:	2101      	movs	r1, #1
    EPR_TOGGLE(i, 0);
 8000892:	f248 0080 	movw	r0, #32896	; 0x8080
 8000896:	008b      	lsls	r3, r1, #2
 8000898:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800089c:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 80008a0:	3101      	adds	r1, #1
    EPR_TOGGLE(i, 0);
 80008a2:	681a      	ldr	r2, [r3, #0]
 80008a4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80008a8:	f042 0280 	orr.w	r2, r2, #128	; 0x80

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 80008ac:	2908      	cmp	r1, #8
    EPR_TOGGLE(i, 0);
 80008ae:	601a      	str	r2, [r3, #0]
    EPR_SET(i, 0);
 80008b0:	6018      	str	r0, [r3, #0]

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 80008b2:	d1f0      	bne.n	8000896 <_usb_ep0setup+0x306>
 80008b4:	2300      	movs	r3, #0
 80008b6:	f383 8811 	msr	BASEPRI, r3
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 80008ba:	6862      	ldr	r2, [r4, #4]
      if (usbp->state == USB_ACTIVE) {
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
 80008bc:	f884 307f 	strb.w	r3, [r4, #127]	; 0x7f
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 80008c0:	6813      	ldr	r3, [r2, #0]
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
 80008c2:	2103      	movs	r1, #3
 80008c4:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 80008c6:	b10b      	cbz	r3, 80008cc <_usb_ep0setup+0x33c>
 80008c8:	4620      	mov	r0, r4
 80008ca:	4798      	blx	r3
 80008cc:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 80008d0:	e786      	b.n	80007e0 <_usb_ep0setup+0x250>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80008d2:	b9eb      	cbnz	r3, 8000910 <_usb_ep0setup+0x380>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 80008d4:	2202      	movs	r2, #2
 80008d6:	f104 017c 	add.w	r1, r4, #124	; 0x7c
 80008da:	6723      	str	r3, [r4, #112]	; 0x70
 80008dc:	66a1      	str	r1, [r4, #104]	; 0x68
 80008de:	66e2      	str	r2, [r4, #108]	; 0x6c
 80008e0:	4613      	mov	r3, r2
 80008e2:	e67b      	b.n	80005dc <_usb_ep0setup+0x4c>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 80008e4:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 80008e8:	4939      	ldr	r1, [pc, #228]	; (80009d0 <_usb_ep0setup+0x440>)
 80008ea:	f012 0f80 	tst.w	r2, #128	; 0x80
 80008ee:	f002 020f 	and.w	r2, r2, #15
 80008f2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80008f6:	d13d      	bne.n	8000974 <_usb_ep0setup+0x3e4>
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) {
 80008f8:	f412 5240 	ands.w	r2, r2, #12288	; 0x3000
 80008fc:	f43f ae99 	beq.w	8000632 <_usb_ep0setup+0xa2>
 8000900:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8000904:	d13c      	bne.n	8000980 <_usb_ep0setup+0x3f0>
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8000906:	4a33      	ldr	r2, [pc, #204]	; (80009d4 <_usb_ep0setup+0x444>)
 8000908:	66e3      	str	r3, [r4, #108]	; 0x6c
 800090a:	6725      	str	r5, [r4, #112]	; 0x70
 800090c:	66a2      	str	r2, [r4, #104]	; 0x68
 800090e:	e665      	b.n	80005dc <_usb_ep0setup+0x4c>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8000910:	2b01      	cmp	r3, #1
 8000912:	f47f ae8e 	bne.w	8000632 <_usb_ep0setup+0xa2>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8000916:	4b30      	ldr	r3, [pc, #192]	; (80009d8 <_usb_ep0setup+0x448>)
 8000918:	66a3      	str	r3, [r4, #104]	; 0x68
 800091a:	2200      	movs	r2, #0
 800091c:	2302      	movs	r3, #2
 800091e:	66e3      	str	r3, [r4, #108]	; 0x6c
 8000920:	6722      	str	r2, [r4, #112]	; 0x70
 8000922:	e65b      	b.n	80005dc <_usb_ep0setup+0x4c>
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8000924:	f894 0079 	ldrb.w	r0, [r4, #121]	; 0x79
 8000928:	6861      	ldr	r1, [r4, #4]
 800092a:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
 800092e:	684e      	ldr	r6, [r1, #4]
 8000930:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 8000934:	f894 1077 	ldrb.w	r1, [r4, #119]	; 0x77
 8000938:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800093c:	4620      	mov	r0, r4
 800093e:	47b0      	blx	r6
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 8000940:	2800      	cmp	r0, #0
 8000942:	f43f ae76 	beq.w	8000632 <_usb_ep0setup+0xa2>
      return false;
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8000946:	6842      	ldr	r2, [r0, #4]
 8000948:	6803      	ldr	r3, [r0, #0]
 800094a:	66e3      	str	r3, [r4, #108]	; 0x6c
 800094c:	66a2      	str	r2, [r4, #104]	; 0x68
 800094e:	6725      	str	r5, [r4, #112]	; 0x70
 8000950:	f894 0074 	ldrb.w	r0, [r4, #116]	; 0x74
 8000954:	e642      	b.n	80005dc <_usb_ep0setup+0x4c>
    }
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8000956:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 800095a:	2b01      	cmp	r3, #1
 800095c:	f47f ae69 	bne.w	8000632 <_usb_ep0setup+0xa2>
      usbp->status |= 2U;
 8000960:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8000964:	66a5      	str	r5, [r4, #104]	; 0x68
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 8000966:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800096a:	66e5      	str	r5, [r4, #108]	; 0x6c
 800096c:	6725      	str	r5, [r4, #112]	; 0x70
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 800096e:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
 8000972:	e713      	b.n	800079c <_usb_ep0setup+0x20c>
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 8000974:	f012 0230 	ands.w	r2, r2, #48	; 0x30
 8000978:	f43f ae5b 	beq.w	8000632 <_usb_ep0setup+0xa2>
 800097c:	2a10      	cmp	r2, #16
 800097e:	d0c2      	beq.n	8000906 <_usb_ep0setup+0x376>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        /*lint -restore*/
        return true;
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8000980:	4a16      	ldr	r2, [pc, #88]	; (80009dc <_usb_ep0setup+0x44c>)
 8000982:	66e3      	str	r3, [r4, #108]	; 0x6c
 8000984:	6725      	str	r5, [r4, #112]	; 0x70
 8000986:	66a2      	str	r2, [r4, #104]	; 0x68
 8000988:	e628      	b.n	80005dc <_usb_ep0setup+0x4c>

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 800098a:	f001 0130 	and.w	r1, r1, #48	; 0x30
 800098e:	2930      	cmp	r1, #48	; 0x30
 8000990:	f43f aedb 	beq.w	800074a <_usb_ep0setup+0x1ba>
    EPR_SET_STAT_TX(ep, EPR_STAT_TX_NAK);
 8000994:	681a      	ldr	r2, [r3, #0]
 8000996:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 800099a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800099e:	f082 0220 	eor.w	r2, r2, #32
 80009a2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80009a6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80009aa:	601a      	str	r2, [r3, #0]
 80009ac:	f894 2074 	ldrb.w	r2, [r4, #116]	; 0x74
 80009b0:	e6cb      	b.n	800074a <_usb_ep0setup+0x1ba>
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 80009b2:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 80009b6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80009ba:	f082 0210 	eor.w	r2, r2, #16
 80009be:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80009c2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80009c6:	601a      	str	r2, [r3, #0]
 80009c8:	f894 2074 	ldrb.w	r2, [r4, #116]	; 0x74
 80009cc:	e6bd      	b.n	800074a <_usb_ep0setup+0x1ba>
 80009ce:	bf00      	nop
 80009d0:	40005c00 	.word	0x40005c00
 80009d4:	08002c50 	.word	0x08002c50
 80009d8:	08002bb0 	.word	0x08002bb0
 80009dc:	08002bc0 	.word	0x08002bc0

080009e0 <_port_irq_epilogue>:
 80009e0:	2320      	movs	r3, #32
 80009e2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80009e6:	4b12      	ldr	r3, [pc, #72]	; (8000a30 <_port_irq_epilogue+0x50>)
 80009e8:	685b      	ldr	r3, [r3, #4]
 80009ea:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80009ee:	d102      	bne.n	80009f6 <_port_irq_epilogue+0x16>
 80009f0:	f383 8811 	msr	BASEPRI, r3
 80009f4:	4770      	bx	lr
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 80009f6:	eef1 3a10 	vmrs	r3, fpscr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80009fa:	f3ef 8309 	mrs	r3, PSP
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80009fe:	4a0d      	ldr	r2, [pc, #52]	; (8000a34 <_port_irq_epilogue+0x54>)
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000a00:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8000a04:	68d2      	ldr	r2, [r2, #12]
 8000a06:	f843 2c08 	str.w	r2, [r3, #-8]
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000a0a:	f843 1c4c 	str.w	r1, [r3, #-76]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000a0e:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
 8000a12:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000a16:	4a08      	ldr	r2, [pc, #32]	; (8000a38 <_port_irq_epilogue+0x58>)
 8000a18:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 8000a1a:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000a1c:	6889      	ldr	r1, [r1, #8]
 8000a1e:	6892      	ldr	r2, [r2, #8]
 8000a20:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000a22:	bf8c      	ite	hi
 8000a24:	4a05      	ldrhi	r2, [pc, #20]	; (8000a3c <_port_irq_epilogue+0x5c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000a26:	4a06      	ldrls	r2, [pc, #24]	; (8000a40 <_port_irq_epilogue+0x60>)
 8000a28:	f843 2c50 	str.w	r2, [r3, #-80]
 8000a2c:	4770      	bx	lr
 8000a2e:	bf00      	nop
 8000a30:	e000ed00 	.word	0xe000ed00
 8000a34:	e000ef30 	.word	0xe000ef30
 8000a38:	20001178 	.word	0x20001178
 8000a3c:	080002d9 	.word	0x080002d9
 8000a40:	080002dc 	.word	0x080002dc
	...

08000a50 <Vector7C>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8000a50:	4b0b      	ldr	r3, [pc, #44]	; (8000a80 <Vector7C+0x30>)
 8000a52:	4a0c      	ldr	r2, [pc, #48]	; (8000a84 <Vector7C+0x34>)
 8000a54:	6819      	ldr	r1, [r3, #0]
 8000a56:	6812      	ldr	r2, [r2, #0]
 8000a58:	0c09      	lsrs	r1, r1, #16
 8000a5a:	f001 010e 	and.w	r1, r1, #14
 8000a5e:	4211      	tst	r1, r2
 8000a60:	d00b      	beq.n	8000a7a <Vector7C+0x2a>
 8000a62:	4809      	ldr	r0, [pc, #36]	; (8000a88 <Vector7C+0x38>)
 8000a64:	6a02      	ldr	r2, [r0, #32]
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8000a66:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8000a68:	040c      	lsls	r4, r1, #16
 8000a6a:	605c      	str	r4, [r3, #4]
 8000a6c:	b10a      	cbz	r2, 8000a72 <Vector7C+0x22>
 8000a6e:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8000a70:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8000a72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);

  OSAL_IRQ_EPILOGUE();
 8000a76:	f7ff bfb3 	b.w	80009e0 <_port_irq_epilogue>
 8000a7a:	f7ff bfb1 	b.w	80009e0 <_port_irq_epilogue>
 8000a7e:	bf00      	nop
 8000a80:	40020000 	.word	0x40020000
 8000a84:	40020058 	.word	0x40020058
 8000a88:	20001098 	.word	0x20001098
 8000a8c:	00000000 	.word	0x00000000

08000a90 <Vector78>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8000a90:	4b0b      	ldr	r3, [pc, #44]	; (8000ac0 <Vector78+0x30>)
 8000a92:	4a0c      	ldr	r2, [pc, #48]	; (8000ac4 <Vector78+0x34>)
 8000a94:	6819      	ldr	r1, [r3, #0]
 8000a96:	6812      	ldr	r2, [r2, #0]
 8000a98:	0b09      	lsrs	r1, r1, #12
 8000a9a:	f001 010e 	and.w	r1, r1, #14
 8000a9e:	4211      	tst	r1, r2
 8000aa0:	d00b      	beq.n	8000aba <Vector78+0x2a>
 8000aa2:	4809      	ldr	r0, [pc, #36]	; (8000ac8 <Vector78+0x38>)
 8000aa4:	6982      	ldr	r2, [r0, #24]
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8000aa6:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8000aa8:	030c      	lsls	r4, r1, #12
 8000aaa:	605c      	str	r4, [r3, #4]
 8000aac:	b10a      	cbz	r2, 8000ab2 <Vector78+0x22>
 8000aae:	69c0      	ldr	r0, [r0, #28]
 8000ab0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8000ab2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);

  OSAL_IRQ_EPILOGUE();
 8000ab6:	f7ff bf93 	b.w	80009e0 <_port_irq_epilogue>
 8000aba:	f7ff bf91 	b.w	80009e0 <_port_irq_epilogue>
 8000abe:	bf00      	nop
 8000ac0:	40020000 	.word	0x40020000
 8000ac4:	40020044 	.word	0x40020044
 8000ac8:	20001098 	.word	0x20001098
 8000acc:	00000000 	.word	0x00000000

08000ad0 <Vector74>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8000ad0:	4b0b      	ldr	r3, [pc, #44]	; (8000b00 <Vector74+0x30>)
 8000ad2:	4a0c      	ldr	r2, [pc, #48]	; (8000b04 <Vector74+0x34>)
 8000ad4:	6819      	ldr	r1, [r3, #0]
 8000ad6:	6812      	ldr	r2, [r2, #0]
 8000ad8:	0a09      	lsrs	r1, r1, #8
 8000ada:	f001 010e 	and.w	r1, r1, #14
 8000ade:	4211      	tst	r1, r2
 8000ae0:	d00b      	beq.n	8000afa <Vector74+0x2a>
 8000ae2:	4809      	ldr	r0, [pc, #36]	; (8000b08 <Vector74+0x38>)
 8000ae4:	6902      	ldr	r2, [r0, #16]
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8000ae6:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8000ae8:	020c      	lsls	r4, r1, #8
 8000aea:	605c      	str	r4, [r3, #4]
 8000aec:	b10a      	cbz	r2, 8000af2 <Vector74+0x22>
 8000aee:	6940      	ldr	r0, [r0, #20]
 8000af0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8000af2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);

  OSAL_IRQ_EPILOGUE();
 8000af6:	f7ff bf73 	b.w	80009e0 <_port_irq_epilogue>
 8000afa:	f7ff bf71 	b.w	80009e0 <_port_irq_epilogue>
 8000afe:	bf00      	nop
 8000b00:	40020000 	.word	0x40020000
 8000b04:	40020030 	.word	0x40020030
 8000b08:	20001098 	.word	0x20001098
 8000b0c:	00000000 	.word	0x00000000

08000b10 <Vector70>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8000b10:	4b0b      	ldr	r3, [pc, #44]	; (8000b40 <Vector70+0x30>)
 8000b12:	4a0c      	ldr	r2, [pc, #48]	; (8000b44 <Vector70+0x34>)
 8000b14:	6819      	ldr	r1, [r3, #0]
 8000b16:	6812      	ldr	r2, [r2, #0]
 8000b18:	0909      	lsrs	r1, r1, #4
 8000b1a:	f001 010e 	and.w	r1, r1, #14
 8000b1e:	4211      	tst	r1, r2
 8000b20:	d00b      	beq.n	8000b3a <Vector70+0x2a>
 8000b22:	4809      	ldr	r0, [pc, #36]	; (8000b48 <Vector70+0x38>)
 8000b24:	6882      	ldr	r2, [r0, #8]
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8000b26:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8000b28:	010c      	lsls	r4, r1, #4
 8000b2a:	605c      	str	r4, [r3, #4]
 8000b2c:	b10a      	cbz	r2, 8000b32 <Vector70+0x22>
 8000b2e:	68c0      	ldr	r0, [r0, #12]
 8000b30:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8000b32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);

  OSAL_IRQ_EPILOGUE();
 8000b36:	f7ff bf53 	b.w	80009e0 <_port_irq_epilogue>
 8000b3a:	f7ff bf51 	b.w	80009e0 <_port_irq_epilogue>
 8000b3e:	bf00      	nop
 8000b40:	40020000 	.word	0x40020000
 8000b44:	4002001c 	.word	0x4002001c
 8000b48:	20001098 	.word	0x20001098
 8000b4c:	00000000 	.word	0x00000000

08000b50 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8000b50:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8000b52:	4b09      	ldr	r3, [pc, #36]	; (8000b78 <Vector6C+0x28>)
 8000b54:	4a09      	ldr	r2, [pc, #36]	; (8000b7c <Vector6C+0x2c>)
 8000b56:	6819      	ldr	r1, [r3, #0]
 8000b58:	6812      	ldr	r2, [r2, #0]
 8000b5a:	f001 010e 	and.w	r1, r1, #14
 8000b5e:	4211      	tst	r1, r2
 8000b60:	d005      	beq.n	8000b6e <Vector6C+0x1e>
 8000b62:	4a07      	ldr	r2, [pc, #28]	; (8000b80 <Vector6C+0x30>)
 8000b64:	6059      	str	r1, [r3, #4]
 8000b66:	6813      	ldr	r3, [r2, #0]
 8000b68:	b10b      	cbz	r3, 8000b6e <Vector6C+0x1e>
 8000b6a:	6850      	ldr	r0, [r2, #4]
 8000b6c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000b6e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);

  OSAL_IRQ_EPILOGUE();
 8000b72:	f7ff bf35 	b.w	80009e0 <_port_irq_epilogue>
 8000b76:	bf00      	nop
 8000b78:	40020000 	.word	0x40020000
 8000b7c:	40020008 	.word	0x40020008
 8000b80:	20001098 	.word	0x20001098
	...

08000b90 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000b90:	4b0e      	ldr	r3, [pc, #56]	; (8000bcc <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000b92:	490f      	ldr	r1, [pc, #60]	; (8000bd0 <chTMStopMeasurementX+0x40>)
 8000b94:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000b96:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000b98:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000b9a:	6f4f      	ldr	r7, [r1, #116]	; 0x74
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8000b9c:	6841      	ldr	r1, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000b9e:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8000ba0:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000ba4:	1ad3      	subs	r3, r2, r3
 8000ba6:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 8000ba8:	18e4      	adds	r4, r4, r3
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 8000baa:	6802      	ldr	r2, [r0, #0]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000bac:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8000bae:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8000bb2:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000bb4:	f106 0601 	add.w	r6, r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8000bb8:	bf88      	it	hi
 8000bba:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 8000bbc:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000bbe:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8000bc0:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 8000bc4:	bf38      	it	cc
 8000bc6:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8000bc8:	bcf0      	pop	{r4, r5, r6, r7}
 8000bca:	4770      	bx	lr
 8000bcc:	e0001000 	.word	0xe0001000
 8000bd0:	20001178 	.word	0x20001178
	...

08000be0 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8000be0:	4a0d      	ldr	r2, [pc, #52]	; (8000c18 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000be2:	6810      	ldr	r0, [r2, #0]

  tqp->p_next = tp->p_next;
 8000be4:	6803      	ldr	r3, [r0, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000be6:	b430      	push	{r4, r5}
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000be8:	2101      	movs	r1, #1
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8000bea:	6994      	ldr	r4, [r2, #24]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000bec:	605a      	str	r2, [r3, #4]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8000bee:	2500      	movs	r5, #0
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000bf0:	7701      	strb	r1, [r0, #28]
 8000bf2:	68a1      	ldr	r1, [r4, #8]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000bf4:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000bf6:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8000bf8:	7725      	strb	r5, [r4, #28]
 8000bfa:	e000      	b.n	8000bfe <chSchDoRescheduleAhead+0x1e>
 8000bfc:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8000bfe:	689a      	ldr	r2, [r3, #8]
 8000c00:	428a      	cmp	r2, r1
 8000c02:	d8fb      	bhi.n	8000bfc <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8000c04:	685a      	ldr	r2, [r3, #4]
 8000c06:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000c08:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8000c0a:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
 8000c0c:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 8000c0e:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
}
 8000c10:	bc30      	pop	{r4, r5}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8000c12:	f7ff bb4d 	b.w	80002b0 <_port_switch>
 8000c16:	bf00      	nop
 8000c18:	20001178 	.word	0x20001178
 8000c1c:	00000000 	.word	0x00000000

08000c20 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8000c20:	f7ff bfde 	b.w	8000be0 <chSchDoRescheduleAhead>
	...

08000c30 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000c30:	4b07      	ldr	r3, [pc, #28]	; (8000c50 <chSchGoSleepS+0x20>)
 8000c32:	6999      	ldr	r1, [r3, #24]
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000c34:	681a      	ldr	r2, [r3, #0]
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000c36:	b410      	push	{r4}
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
  otp->p_state = newstate;
 8000c38:	7708      	strb	r0, [r1, #28]

  tqp->p_next = tp->p_next;
 8000c3a:	6810      	ldr	r0, [r2, #0]
 8000c3c:	6018      	str	r0, [r3, #0]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000c3e:	2401      	movs	r4, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000c40:	6043      	str	r3, [r0, #4]
 8000c42:	7714      	strb	r4, [r2, #28]
  chSysSwitch(currp, otp);
 8000c44:	4610      	mov	r0, r2
}
 8000c46:	f85d 4b04 	ldr.w	r4, [sp], #4
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000c4a:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8000c4c:	f7ff bb30 	b.w	80002b0 <_port_switch>
 8000c50:	20001178 	.word	0x20001178
	...

08000c60 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000c60:	b5f0      	push	{r4, r5, r6, r7, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000c62:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000c64:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000c66:	d04d      	beq.n	8000d04 <chSchGoSleepTimeoutS+0xa4>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000c68:	4c41      	ldr	r4, [pc, #260]	; (8000d70 <chSchGoSleepTimeoutS+0x110>)
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000c6a:	4625      	mov	r5, r4
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8000c6c:	69a3      	ldr	r3, [r4, #24]
 8000c6e:	9305      	str	r3, [sp, #20]
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000c70:	f855 3f1c 	ldr.w	r3, [r5, #28]!
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000c74:	2901      	cmp	r1, #1
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000c76:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
 8000c7a:	4607      	mov	r7, r0
 8000c7c:	bf98      	it	ls
 8000c7e:	2102      	movls	r1, #2

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 8000c80:	483c      	ldr	r0, [pc, #240]	; (8000d74 <chSchGoSleepTimeoutS+0x114>)
 8000c82:	f8de 2024 	ldr.w	r2, [lr, #36]	; 0x24
 8000c86:	9004      	str	r0, [sp, #16]
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000c88:	42ab      	cmp	r3, r5
 8000c8a:	d05b      	beq.n	8000d44 <chSchGoSleepTimeoutS+0xe4>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.vt_next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.vt_lasttime + delay;
 8000c8c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8000c8e:	1a12      	subs	r2, r2, r0

    if (delta < now - ch.vtlist.vt_lasttime) {
 8000c90:	1889      	adds	r1, r1, r2
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->vt_delta;
 8000c92:	689a      	ldr	r2, [r3, #8]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.vt_lasttime + delay;

    if (delta < now - ch.vtlist.vt_lasttime) {
 8000c94:	d232      	bcs.n	8000cfc <chSchGoSleepTimeoutS+0x9c>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->vt_delta;
      p = p->vt_next;
    }
    else if (delta < p->vt_delta) {
 8000c96:	4291      	cmp	r1, r2
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 8000c98:	bf3c      	itt	cc
 8000c9a:	1840      	addcc	r0, r0, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000c9c:	f8ce 0034 	strcc.w	r0, [lr, #52]	; 0x34
  p = ch.vtlist.vt_next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 8000ca0:	4291      	cmp	r1, r2
 8000ca2:	d904      	bls.n	8000cae <chSchGoSleepTimeoutS+0x4e>
    delta -= p->vt_delta;
    p = p->vt_next;
 8000ca4:	681b      	ldr	r3, [r3, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8000ca6:	1a89      	subs	r1, r1, r2
  p = ch.vtlist.vt_next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 8000ca8:	689a      	ldr	r2, [r3, #8]
 8000caa:	428a      	cmp	r2, r1
 8000cac:	d3fa      	bcc.n	8000ca4 <chSchGoSleepTimeoutS+0x44>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8000cae:	685a      	ldr	r2, [r3, #4]
 8000cb0:	9202      	str	r2, [sp, #8]
  vtp->vt_prev->vt_next = vtp;
 8000cb2:	ae01      	add	r6, sp, #4
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8000cb4:	9301      	str	r3, [sp, #4]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 8000cb6:	6016      	str	r6, [r2, #0]
  p->vt_prev = vtp;
 8000cb8:	605e      	str	r6, [r3, #4]
  vtp->vt_delta = delta
 8000cba:	9103      	str	r1, [sp, #12]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000cbc:	689a      	ldr	r2, [r3, #8]
 8000cbe:	1a51      	subs	r1, r2, r1
  ch.vtlist.vt_delta = (systime_t)-1;
 8000cc0:	f04f 32ff 	mov.w	r2, #4294967295
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000cc4:	6099      	str	r1, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000cc6:	6262      	str	r2, [r4, #36]	; 0x24
    chSchGoSleepS(newstate);
 8000cc8:	4638      	mov	r0, r7
 8000cca:	f7ff ffb1 	bl	8000c30 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000cce:	9b04      	ldr	r3, [sp, #16]
 8000cd0:	b183      	cbz	r3, 8000cf4 <chSchGoSleepTimeoutS+0x94>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8000cd2:	69e3      	ldr	r3, [r4, #28]
 8000cd4:	4a26      	ldr	r2, [pc, #152]	; (8000d70 <chSchGoSleepTimeoutS+0x110>)
 8000cd6:	42b3      	cmp	r3, r6
 8000cd8:	d01b      	beq.n	8000d12 <chSchGoSleepTimeoutS+0xb2>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8000cda:	9a02      	ldr	r2, [sp, #8]
 8000cdc:	9b01      	ldr	r3, [sp, #4]
 8000cde:	6013      	str	r3, [r2, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8000ce0:	9b01      	ldr	r3, [sp, #4]
    vtp->vt_func = NULL;
 8000ce2:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8000ce4:	42ab      	cmp	r3, r5
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8000ce6:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 8000ce8:	9104      	str	r1, [sp, #16]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8000cea:	d003      	beq.n	8000cf4 <chSchGoSleepTimeoutS+0x94>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8000cec:	6899      	ldr	r1, [r3, #8]
 8000cee:	9a03      	ldr	r2, [sp, #12]
 8000cf0:	440a      	add	r2, r1
 8000cf2:	609a      	str	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8000cf4:	69a3      	ldr	r3, [r4, #24]
}
 8000cf6:	6a18      	ldr	r0, [r3, #32]
 8000cf8:	b007      	add	sp, #28
 8000cfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (delta < now - ch.vtlist.vt_lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->vt_delta;
      p = p->vt_next;
 8000cfc:	681b      	ldr	r3, [r3, #0]

    if (delta < now - ch.vtlist.vt_lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->vt_delta;
 8000cfe:	1a89      	subs	r1, r1, r2
 8000d00:	689a      	ldr	r2, [r3, #8]
 8000d02:	e7cd      	b.n	8000ca0 <chSchGoSleepTimeoutS+0x40>
 8000d04:	4c1a      	ldr	r4, [pc, #104]	; (8000d70 <chSchGoSleepTimeoutS+0x110>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000d06:	f7ff ff93 	bl	8000c30 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000d0a:	69a3      	ldr	r3, [r4, #24]
}
 8000d0c:	6a18      	ldr	r0, [r3, #32]
 8000d0e:	b007      	add	sp, #28
 8000d10:	bdf0      	pop	{r4, r5, r6, r7, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8000d12:	9901      	ldr	r1, [sp, #4]
 8000d14:	61d1      	str	r1, [r2, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 8000d16:	2300      	movs	r3, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000d18:	42a9      	cmp	r1, r5
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000d1a:	604d      	str	r5, [r1, #4]
  vtp->vt_func = NULL;
 8000d1c:	9304      	str	r3, [sp, #16]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000d1e:	d022      	beq.n	8000d66 <chSchGoSleepTimeoutS+0x106>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8000d20:	6888      	ldr	r0, [r1, #8]
 8000d22:	9b03      	ldr	r3, [sp, #12]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8000d24:	6a92      	ldr	r2, [r2, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8000d26:	4403      	add	r3, r0
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000d28:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000d2c:	608b      	str	r3, [r1, #8]
 8000d2e:	6a41      	ldr	r1, [r0, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8000d30:	1a8a      	subs	r2, r1, r2

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8000d32:	4293      	cmp	r3, r2
 8000d34:	d9de      	bls.n	8000cf4 <chSchGoSleepTimeoutS+0x94>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 8000d36:	1a9b      	subs	r3, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000d38:	2b01      	cmp	r3, #1
 8000d3a:	bf98      	it	ls
 8000d3c:	2302      	movls	r3, #2
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8000d3e:	440b      	add	r3, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000d40:	6343      	str	r3, [r0, #52]	; 0x34
 8000d42:	e7d7      	b.n	8000cf4 <chSchGoSleepTimeoutS+0x94>
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 8000d44:	62a2      	str	r2, [r4, #40]	; 0x28
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8000d46:	1850      	adds	r0, r2, r1
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
 8000d48:	ae01      	add	r6, sp, #4
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
 8000d4a:	2200      	movs	r2, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000d4c:	2302      	movs	r3, #2
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8000d4e:	9501      	str	r5, [sp, #4]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000d50:	9502      	str	r5, [sp, #8]
      vtp->vt_delta = delay;
 8000d52:	9103      	str	r1, [sp, #12]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
 8000d54:	61e6      	str	r6, [r4, #28]
      ch.vtlist.vt_prev = vtp;
 8000d56:	6226      	str	r6, [r4, #32]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000d58:	f8ce 0034 	str.w	r0, [lr, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000d5c:	f8ce 2010 	str.w	r2, [lr, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000d60:	f8ce 300c 	str.w	r3, [lr, #12]
 8000d64:	e7b0      	b.n	8000cc8 <chSchGoSleepTimeoutS+0x68>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000d66:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000d6a:	60d3      	str	r3, [r2, #12]
 8000d6c:	e7c2      	b.n	8000cf4 <chSchGoSleepTimeoutS+0x94>
 8000d6e:	bf00      	nop
 8000d70:	20001178 	.word	0x20001178
 8000d74:	08000371 	.word	0x08000371
	...

08000d80 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8000d80:	b169      	cbz	r1, 8000d9e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000d82:	4b08      	ldr	r3, [pc, #32]	; (8000da4 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8000d84:	b410      	push	{r4}
 8000d86:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8000d88:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000d8a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000d8c:	2004      	movs	r0, #4
 8000d8e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 8000d92:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 8000d94:	6053      	str	r3, [r2, #4]
}
 8000d96:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000d9a:	f7ff bf61 	b.w	8000c60 <chSchGoSleepTimeoutS>
}
 8000d9e:	f04f 30ff 	mov.w	r0, #4294967295
 8000da2:	4770      	bx	lr
 8000da4:	20001178 	.word	0x20001178
	...

08000db0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8000db0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000db4:	b083      	sub	sp, #12
 8000db6:	4604      	mov	r4, r0
 8000db8:	460d      	mov	r5, r1
 8000dba:	4616      	mov	r6, r2
 8000dbc:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8000dbe:	f8d0 801c 	ldr.w	r8, [r0, #28]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000dc2:	f04f 0920 	mov.w	r9, #32
 8000dc6:	f389 8811 	msr	BASEPRI, r9
  size_t w = 0;
 8000dca:	2700      	movs	r7, #0
 8000dcc:	46ba      	mov	sl, r7
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8000dce:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000dd0:	f105 0b01 	add.w	fp, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8000dd4:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8000dd6:	b303      	cbz	r3, 8000e1a <chOQWriteTimeout+0x6a>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000dd8:	6961      	ldr	r1, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8000dda:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8000ddc:	1c4a      	adds	r2, r1, #1
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8000dde:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 8000de0:	6162      	str	r2, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8000de2:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8000de4:	782b      	ldrb	r3, [r5, #0]
 8000de6:	700b      	strb	r3, [r1, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8000de8:	6923      	ldr	r3, [r4, #16]
 8000dea:	6961      	ldr	r1, [r4, #20]
 8000dec:	4299      	cmp	r1, r3
      oqp->q_wrptr = oqp->q_buffer;
 8000dee:	bf24      	itt	cs
 8000df0:	68e3      	ldrcs	r3, [r4, #12]
 8000df2:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 8000df4:	f1b8 0f00 	cmp.w	r8, #0
 8000df8:	d000      	beq.n	8000dfc <chOQWriteTimeout+0x4c>
      nfy(oqp);
 8000dfa:	47c0      	blx	r8
 8000dfc:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 8000e00:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 8000e02:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
 8000e06:	d012      	beq.n	8000e2e <chOQWriteTimeout+0x7e>
 8000e08:	f389 8811 	msr	BASEPRI, r9
 8000e0c:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000e0e:	465d      	mov	r5, fp
 8000e10:	f105 0b01 	add.w	fp, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8000e14:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8000e16:	2b00      	cmp	r3, #0
 8000e18:	d1de      	bne.n	8000dd8 <chOQWriteTimeout+0x28>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8000e1a:	9901      	ldr	r1, [sp, #4]
 8000e1c:	9300      	str	r3, [sp, #0]
 8000e1e:	4620      	mov	r0, r4
 8000e20:	f7ff ffae 	bl	8000d80 <chThdEnqueueTimeoutS>
 8000e24:	9b00      	ldr	r3, [sp, #0]
 8000e26:	2800      	cmp	r0, #0
 8000e28:	d0d1      	beq.n	8000dce <chOQWriteTimeout+0x1e>
 8000e2a:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 8000e2e:	4638      	mov	r0, r7
 8000e30:	b003      	add	sp, #12
 8000e32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000e36:	bf00      	nop
	...

08000e40 <writet.lto_priv.56>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000e40:	3030      	adds	r0, #48	; 0x30
 8000e42:	f7ff bfb5 	b.w	8000db0 <chOQWriteTimeout>
 8000e46:	bf00      	nop
	...

08000e50 <write.lto_priv.50>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000e50:	3030      	adds	r0, #48	; 0x30
 8000e52:	f04f 33ff 	mov.w	r3, #4294967295
 8000e56:	f7ff bfab 	b.w	8000db0 <chOQWriteTimeout>
 8000e5a:	bf00      	nop
 8000e5c:	0000      	movs	r0, r0
	...

08000e60 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8000e60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000e62:	4604      	mov	r4, r0
 8000e64:	460f      	mov	r7, r1
 8000e66:	4616      	mov	r6, r2
 8000e68:	2320      	movs	r3, #32
 8000e6a:	f383 8811 	msr	BASEPRI, r3
 8000e6e:	e003      	b.n	8000e78 <chOQPutTimeout+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8000e70:	f7ff ff86 	bl	8000d80 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8000e74:	2800      	cmp	r0, #0
 8000e76:	db19      	blt.n	8000eac <chOQPutTimeout+0x4c>
 8000e78:	68a5      	ldr	r5, [r4, #8]
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8000e7a:	4631      	mov	r1, r6
 8000e7c:	4620      	mov	r0, r4
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8000e7e:	2d00      	cmp	r5, #0
 8000e80:	d0f6      	beq.n	8000e70 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000e82:	6962      	ldr	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000e84:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000e86:	1c51      	adds	r1, r2, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000e88:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8000e8a:	6161      	str	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000e8c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000e8e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000e90:	6923      	ldr	r3, [r4, #16]
 8000e92:	6962      	ldr	r2, [r4, #20]
 8000e94:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000e96:	bf24      	itt	cs
 8000e98:	68e3      	ldrcs	r3, [r4, #12]
 8000e9a:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8000e9c:	69e3      	ldr	r3, [r4, #28]
 8000e9e:	b10b      	cbz	r3, 8000ea4 <chOQPutTimeout+0x44>
    oqp->q_notify(oqp);
 8000ea0:	4620      	mov	r0, r4
 8000ea2:	4798      	blx	r3
 8000ea4:	2000      	movs	r0, #0
 8000ea6:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8000eaa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000eac:	f385 8811 	msr	BASEPRI, r5
 8000eb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000eb2:	bf00      	nop
	...

08000ec0 <putt.lto_priv.54>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000ec0:	3030      	adds	r0, #48	; 0x30
 8000ec2:	f7ff bfcd 	b.w	8000e60 <chOQPutTimeout>
 8000ec6:	bf00      	nop
	...

08000ed0 <put.lto_priv.52>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000ed0:	3030      	adds	r0, #48	; 0x30
 8000ed2:	f04f 32ff 	mov.w	r2, #4294967295
 8000ed6:	f7ff bfc3 	b.w	8000e60 <chOQPutTimeout>
 8000eda:	bf00      	nop
 8000edc:	0000      	movs	r0, r0
	...

08000ee0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8000ee0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000ee4:	4604      	mov	r4, r0
 8000ee6:	b083      	sub	sp, #12
 8000ee8:	4689      	mov	r9, r1
 8000eea:	4693      	mov	fp, r2
 8000eec:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 8000eee:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8000ef2:	2720      	movs	r7, #32
 8000ef4:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
 8000ef8:	2600      	movs	r6, #0
 8000efa:	9701      	str	r7, [sp, #4]
 8000efc:	46b2      	mov	sl, r6

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 8000efe:	f1b8 0f00 	cmp.w	r8, #0
 8000f02:	d005      	beq.n	8000f10 <chIQReadTimeout+0x30>
      nfy(iqp);
 8000f04:	4620      	mov	r0, r4
 8000f06:	47c0      	blx	r8
 8000f08:	e002      	b.n	8000f10 <chIQReadTimeout+0x30>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8000f0a:	f7ff ff39 	bl	8000d80 <chThdEnqueueTimeoutS>
 8000f0e:	b9e0      	cbnz	r0, 8000f4a <chIQReadTimeout+0x6a>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8000f10:	68a7      	ldr	r7, [r4, #8]
 8000f12:	4629      	mov	r1, r5
 8000f14:	4620      	mov	r0, r4
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8000f16:	2f00      	cmp	r7, #0
 8000f18:	d0f7      	beq.n	8000f0a <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8000f1a:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000f1c:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8000f1e:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000f20:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 8000f22:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000f24:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8000f26:	7813      	ldrb	r3, [r2, #0]
 8000f28:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top) {
 8000f2c:	6923      	ldr	r3, [r4, #16]
 8000f2e:	69a2      	ldr	r2, [r4, #24]
 8000f30:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8000f32:	bf24      	itt	cs
 8000f34:	68e3      	ldrcs	r3, [r4, #12]
 8000f36:	61a3      	strcs	r3, [r4, #24]
 8000f38:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 8000f3c:	3601      	adds	r6, #1
    if (--n == 0U) {
 8000f3e:	45b3      	cmp	fp, r6
 8000f40:	d005      	beq.n	8000f4e <chIQReadTimeout+0x6e>
 8000f42:	9b01      	ldr	r3, [sp, #4]
 8000f44:	f383 8811 	msr	BASEPRI, r3
 8000f48:	e7d9      	b.n	8000efe <chIQReadTimeout+0x1e>
 8000f4a:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 8000f4e:	4630      	mov	r0, r6
 8000f50:	b003      	add	sp, #12
 8000f52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000f56:	bf00      	nop
	...

08000f60 <readt.lto_priv.57>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000f60:	300c      	adds	r0, #12
 8000f62:	f7ff bfbd 	b.w	8000ee0 <chIQReadTimeout>
 8000f66:	bf00      	nop
	...

08000f70 <read.lto_priv.51>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000f70:	300c      	adds	r0, #12
 8000f72:	f04f 33ff 	mov.w	r3, #4294967295
 8000f76:	f7ff bfb3 	b.w	8000ee0 <chIQReadTimeout>
 8000f7a:	bf00      	nop
 8000f7c:	0000      	movs	r0, r0
	...

08000f80 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8000f80:	b570      	push	{r4, r5, r6, lr}
 8000f82:	2320      	movs	r3, #32
 8000f84:	460e      	mov	r6, r1
 8000f86:	4604      	mov	r4, r0
 8000f88:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 8000f8c:	69c3      	ldr	r3, [r0, #28]
 8000f8e:	b12b      	cbz	r3, 8000f9c <chIQGetTimeout+0x1c>
    iqp->q_notify(iqp);
 8000f90:	4798      	blx	r3
 8000f92:	e003      	b.n	8000f9c <chIQGetTimeout+0x1c>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8000f94:	f7ff fef4 	bl	8000d80 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8000f98:	2800      	cmp	r0, #0
 8000f9a:	db15      	blt.n	8000fc8 <chIQGetTimeout+0x48>
 8000f9c:	68a5      	ldr	r5, [r4, #8]
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8000f9e:	4631      	mov	r1, r6
 8000fa0:	4620      	mov	r0, r4
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8000fa2:	2d00      	cmp	r5, #0
 8000fa4:	d0f6      	beq.n	8000f94 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000fa6:	69a1      	ldr	r1, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000fa8:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8000faa:	6925      	ldr	r5, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000fac:	1c4a      	adds	r2, r1, #1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000fae:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8000fb0:	42aa      	cmp	r2, r5
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000fb2:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8000fb4:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8000fb6:	bf28      	it	cs
 8000fb8:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000fba:	7808      	ldrb	r0, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8000fbc:	bf28      	it	cs
 8000fbe:	61a3      	strcs	r3, [r4, #24]
 8000fc0:	2300      	movs	r3, #0
 8000fc2:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
}
 8000fc6:	bd70      	pop	{r4, r5, r6, pc}
 8000fc8:	f385 8811 	msr	BASEPRI, r5
 8000fcc:	bd70      	pop	{r4, r5, r6, pc}
 8000fce:	bf00      	nop

08000fd0 <gett.lto_priv.55>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000fd0:	300c      	adds	r0, #12
 8000fd2:	f7ff bfd5 	b.w	8000f80 <chIQGetTimeout>
 8000fd6:	bf00      	nop
	...

08000fe0 <get.lto_priv.53>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000fe0:	300c      	adds	r0, #12
 8000fe2:	f04f 31ff 	mov.w	r1, #4294967295
 8000fe6:	f7ff bfcb 	b.w	8000f80 <chIQGetTimeout>
 8000fea:	bf00      	nop
 8000fec:	0000      	movs	r0, r0
	...

08000ff0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000ff0:	b508      	push	{r3, lr}
 8000ff2:	4601      	mov	r1, r0
 8000ff4:	2320      	movs	r3, #32
 8000ff6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000ffa:	2008      	movs	r0, #8
 8000ffc:	f7ff fe30 	bl	8000c60 <chSchGoSleepTimeoutS>
 8001000:	2300      	movs	r3, #0
 8001002:	f383 8811 	msr	BASEPRI, r3
 8001006:	bd08      	pop	{r3, pc}
	...

08001010 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001010:	2200      	movs	r2, #0
 8001012:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001014:	4b08      	ldr	r3, [pc, #32]	; (8001038 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001016:	b410      	push	{r4}
 8001018:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800101a:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800101c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800101e:	689a      	ldr	r2, [r3, #8]
 8001020:	428a      	cmp	r2, r1
 8001022:	d2fb      	bcs.n	800101c <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001024:	685a      	ldr	r2, [r3, #4]
 8001026:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001028:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 800102a:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800102c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800102e:	605c      	str	r4, [r3, #4]

  return tp;
}
 8001030:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001034:	4770      	bx	lr
 8001036:	bf00      	nop
 8001038:	20001178 	.word	0x20001178
 800103c:	00000000 	.word	0x00000000

08001040 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001040:	b538      	push	{r3, r4, r5, lr}
 8001042:	2220      	movs	r2, #32
 8001044:	4603      	mov	r3, r0
 8001046:	f382 8811 	msr	BASEPRI, r2
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 800104a:	4a0e      	ldr	r2, [pc, #56]	; (8001084 <chThdExit+0x44>)
 800104c:	6994      	ldr	r4, [r2, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800104e:	6a60      	ldr	r0, [r4, #36]	; 0x24

  tp->p_u.exitcode = msg;
 8001050:	6223      	str	r3, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001052:	f104 0524 	add.w	r5, r4, #36	; 0x24
 8001056:	4285      	cmp	r5, r0
 8001058:	d006      	beq.n	8001068 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 800105a:	6803      	ldr	r3, [r0, #0]
 800105c:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 800105e:	f7ff ffd7 	bl	8001010 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001062:	6a60      	ldr	r0, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001064:	42a8      	cmp	r0, r5
 8001066:	d1f8      	bne.n	800105a <chThdExit+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8001068:	7f63      	ldrb	r3, [r4, #29]
 800106a:	079b      	lsls	r3, r3, #30
 800106c:	d104      	bne.n	8001078 <chThdExit+0x38>
    REG_REMOVE(tp);
 800106e:	6963      	ldr	r3, [r4, #20]
 8001070:	6922      	ldr	r2, [r4, #16]
 8001072:	611a      	str	r2, [r3, #16]
 8001074:	6922      	ldr	r2, [r4, #16]
 8001076:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001078:	200f      	movs	r0, #15
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 800107a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800107e:	f7ff bdd7 	b.w	8000c30 <chSchGoSleepS>
 8001082:	bf00      	nop
 8001084:	20001178 	.word	0x20001178
	...

08001090 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8001090:	e7fe      	b.n	8001090 <BusFault_Handler>
 8001092:	bf00      	nop
	...

080010a0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80010a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80010a2:	4f13      	ldr	r7, [pc, #76]	; (80010f0 <__init_ram_areas+0x50>)
 80010a4:	4d13      	ldr	r5, [pc, #76]	; (80010f4 <__init_ram_areas+0x54>)
 80010a6:	4c14      	ldr	r4, [pc, #80]	; (80010f8 <__init_ram_areas+0x58>)
 80010a8:	4b14      	ldr	r3, [pc, #80]	; (80010fc <__init_ram_areas+0x5c>)
 80010aa:	4915      	ldr	r1, [pc, #84]	; (8001100 <__init_ram_areas+0x60>)
 80010ac:	f107 0e70 	add.w	lr, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 80010b0:	2600      	movs	r6, #0
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80010b2:	429c      	cmp	r4, r3
 80010b4:	d911      	bls.n	80010da <__init_ram_areas+0x3a>
 80010b6:	3904      	subs	r1, #4
 80010b8:	461a      	mov	r2, r3
      *p = *tp;
 80010ba:	f851 0f04 	ldr.w	r0, [r1, #4]!
 80010be:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80010c2:	4294      	cmp	r4, r2
 80010c4:	d8f9      	bhi.n	80010ba <__init_ram_areas+0x1a>
 80010c6:	43da      	mvns	r2, r3
 80010c8:	4414      	add	r4, r2
 80010ca:	f024 0403 	bic.w	r4, r4, #3
 80010ce:	3404      	adds	r4, #4
 80010d0:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80010d2:	429d      	cmp	r5, r3
 80010d4:	d903      	bls.n	80010de <__init_ram_areas+0x3e>
      *p = 0;
 80010d6:	f843 6b04 	str.w	r6, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80010da:	429d      	cmp	r5, r3
 80010dc:	d8fb      	bhi.n	80010d6 <__init_ram_areas+0x36>
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80010de:	4577      	cmp	r7, lr
 80010e0:	d005      	beq.n	80010ee <__init_ram_areas+0x4e>
 80010e2:	6939      	ldr	r1, [r7, #16]
 80010e4:	697b      	ldr	r3, [r7, #20]
 80010e6:	69bc      	ldr	r4, [r7, #24]
 80010e8:	69fd      	ldr	r5, [r7, #28]
 80010ea:	3710      	adds	r7, #16
 80010ec:	e7e1      	b.n	80010b2 <__init_ram_areas+0x12>
 80010ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80010f0:	08002bd0 	.word	0x08002bd0
 80010f4:	20001388 	.word	0x20001388
 80010f8:	20001388 	.word	0x20001388
 80010fc:	20001388 	.word	0x20001388
 8001100:	08002ddc 	.word	0x08002ddc
	...

08001110 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001110:	e7fe      	b.n	8001110 <__default_exit>
 8001112:	bf00      	nop
	...

08001120 <__late_init>:
 8001120:	4770      	bx	lr
 8001122:	bf00      	nop
	...

08001130 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 8001130:	4770      	bx	lr
 8001132:	bf00      	nop
	...

08001140 <notify1.lto_priv.48>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8001140:	4a02      	ldr	r2, [pc, #8]	; (800114c <notify1.lto_priv.48+0xc>)
 8001142:	6813      	ldr	r3, [r2, #0]
 8001144:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001148:	6013      	str	r3, [r2, #0]
 800114a:	4770      	bx	lr
 800114c:	40013800 	.word	0x40013800

08001150 <Vector16C>:
/**
 * @brief   USB low priority interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 8001150:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t istr;
  USBDriver *usbp = &USBD1;

  OSAL_IRQ_PROLOGUE();

  istr = STM32_USB->ISTR;
 8001154:	4ba2      	ldr	r3, [pc, #648]	; (80013e0 <Vector16C+0x290>)
 8001156:	6c5d      	ldr	r5, [r3, #68]	; 0x44

  /* USB bus reset condition handling.*/
  if (istr & ISTR_RESET) {
 8001158:	056f      	lsls	r7, r5, #21
/**
 * @brief   USB low priority interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 800115a:	b083      	sub	sp, #12
  OSAL_IRQ_PROLOGUE();

  istr = STM32_USB->ISTR;

  /* USB bus reset condition handling.*/
  if (istr & ISTR_RESET) {
 800115c:	f100 8144 	bmi.w	80013e8 <Vector16C+0x298>

    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
 8001160:	052e      	lsls	r6, r5, #20
 8001162:	f100 8121 	bmi.w	80013a8 <Vector16C+0x258>

    _usb_suspend(usbp);
  }

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
 8001166:	04ec      	lsls	r4, r5, #19
 8001168:	d508      	bpl.n	800117c <Vector16C+0x2c>
    uint32_t fnr = STM32_USB->FNR;
 800116a:	4b9d      	ldr	r3, [pc, #628]	; (80013e0 <Vector16C+0x290>)
 800116c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    if (!(fnr & FNR_RXDP)) {
 800116e:	0410      	lsls	r0, r2, #16
 8001170:	f140 819a 	bpl.w	80014a8 <Vector16C+0x358>
      /* Just noise, going back in SUSPEND mode, reference manual 22.4.5,
         table 169.*/
      STM32_USB->CNTR |= CNTR_LP_MODE;
    }
#endif
    STM32_USB->ISTR = ~ISTR_WKUP;
 8001174:	4b9a      	ldr	r3, [pc, #616]	; (80013e0 <Vector16C+0x290>)
 8001176:	f46f 5280 	mvn.w	r2, #4096	; 0x1000
 800117a:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* SOF handling.*/
  if (istr & ISTR_SOF) {
 800117c:	05a9      	lsls	r1, r5, #22
 800117e:	d50b      	bpl.n	8001198 <Vector16C+0x48>
    _usb_isr_invoke_sof_cb(usbp);
 8001180:	f8df 8260 	ldr.w	r8, [pc, #608]	; 80013e4 <Vector16C+0x294>
 8001184:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8001188:	68db      	ldr	r3, [r3, #12]
 800118a:	b10b      	cbz	r3, 8001190 <Vector16C+0x40>
 800118c:	4640      	mov	r0, r8
 800118e:	4798      	blx	r3
    STM32_USB->ISTR = ~ISTR_SOF;
 8001190:	4b93      	ldr	r3, [pc, #588]	; (80013e0 <Vector16C+0x290>)
 8001192:	f46f 7200 	mvn.w	r2, #512	; 0x200
 8001196:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
 8001198:	042a      	lsls	r2, r5, #16
 800119a:	f140 80d4 	bpl.w	8001346 <Vector16C+0x1f6>
 800119e:	f8df 8244 	ldr.w	r8, [pc, #580]	; 80013e4 <Vector16C+0x294>
 * @notapi
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80011a2:	f8df a23c 	ldr.w	sl, [pc, #572]	; 80013e0 <Vector16C+0x290>
    STM32_USB->ISTR = ~ISTR_SOF;
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
 80011a6:	f005 050f 	and.w	r5, r5, #15
 80011aa:	00ac      	lsls	r4, r5, #2
 80011ac:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 80011b0:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 * @notapi
 */
static void usb_serve_endpoints(USBDriver *usbp, uint32_t ep) {
  size_t n;
  uint32_t epr = STM32_USB->EPR[ep];
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80011b4:	1cae      	adds	r6, r5, #2
 *
 * @notapi
 */
static void usb_serve_endpoints(USBDriver *usbp, uint32_t ep) {
  size_t n;
  uint32_t epr = STM32_USB->EPR[ep];
 80011b6:	f8d4 9000 	ldr.w	r9, [r4]
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80011ba:	eb08 0386 	add.w	r3, r8, r6, lsl #2

  if (epr & EPR_CTR_TX) {
 80011be:	f019 0f80 	tst.w	r9, #128	; 0x80
 * @notapi
 */
static void usb_serve_endpoints(USBDriver *usbp, uint32_t ep) {
  size_t n;
  uint32_t epr = STM32_USB->EPR[ep];
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80011c2:	685f      	ldr	r7, [r3, #4]

  if (epr & EPR_CTR_TX) {
 80011c4:	d04b      	beq.n	800125e <Vector16C+0x10e>
    /* IN endpoint, transmission.*/
    USBInEndpointState *isp = epcp->in_state;
 80011c6:	f8d7 e014 	ldr.w	lr, [r7, #20]

    EPR_CLEAR_CTR_TX(ep);
 80011ca:	6822      	ldr	r2, [r4, #0]

    isp->txcnt += isp->txlast;
 80011cc:	f8de 100c 	ldr.w	r1, [lr, #12]
    n = isp->txsize - isp->txcnt;
 80011d0:	e89e 0009 	ldmia.w	lr, {r0, r3}

  if (epr & EPR_CTR_TX) {
    /* IN endpoint, transmission.*/
    USBInEndpointState *isp = epcp->in_state;

    EPR_CLEAR_CTR_TX(ep);
 80011d4:	f422 4278 	bic.w	r2, r2, #63488	; 0xf800
 80011d8:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0

    isp->txcnt += isp->txlast;
 80011dc:	440b      	add	r3, r1

  if (epr & EPR_CTR_TX) {
    /* IN endpoint, transmission.*/
    USBInEndpointState *isp = epcp->in_state;

    EPR_CLEAR_CTR_TX(ep);
 80011de:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80011e2:	6022      	str	r2, [r4, #0]

    isp->txcnt += isp->txlast;
 80011e4:	f8ce 3004 	str.w	r3, [lr, #4]
    n = isp->txsize - isp->txcnt;
    if (n > 0) {
 80011e8:	1ac3      	subs	r3, r0, r3
 80011ea:	f000 80c3 	beq.w	8001374 <Vector16C+0x224>
      /* Transfer not completed, there are more packets to send.*/
      if (n > epcp->in_maxsize)
 80011ee:	8a38      	ldrh	r0, [r7, #16]
        n = epcp->in_maxsize;

      /* Writes the packet from the defined buffer.*/
      isp->txbuf += isp->txlast;
 80011f0:	f8de 2008 	ldr.w	r2, [lr, #8]
 80011f4:	4298      	cmp	r0, r3
 80011f6:	bf28      	it	cs
 80011f8:	4618      	movcs	r0, r3
      isp->txlast = n;
 80011fa:	f8ce 000c 	str.w	r0, [lr, #12]
 * @notapi
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80011fe:	f8da 3050 	ldr.w	r3, [sl, #80]	; 0x50
 8001202:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001206:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 800120a:	ea4f 1b05 	mov.w	fp, r5, lsl #4
 800120e:	eb0b 0c03 	add.w	ip, fp, r3
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8001212:	f85b 3003 	ldr.w	r3, [fp, r3]
 8001216:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800121a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
      /* Transfer not completed, there are more packets to send.*/
      if (n > epcp->in_maxsize)
        n = epcp->in_maxsize;

      /* Writes the packet from the defined buffer.*/
      isp->txbuf += isp->txlast;
 800121e:	440a      	add	r2, r1
 8001220:	f8ce 2008 	str.w	r2, [lr, #8]
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8001224:	005b      	lsls	r3, r3, #1
  if (EPR_EP_TYPE_IS_ISO(epr) && (epr & EPR_DTOG_TX))
    udp->TXCOUNT1 = (stm32_usb_pma_t)n;
  else
    udp->TXCOUNT0 = (stm32_usb_pma_t)n;
#else
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 8001226:	f8cc 0004 	str.w	r0, [ip, #4]
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 800122a:	b160      	cbz	r0, 8001246 <Vector16C+0xf6>
 800122c:	3801      	subs	r0, #1
 800122e:	0840      	lsrs	r0, r0, #1
 8001230:	3304      	adds	r3, #4
 8001232:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8001236:	e000      	b.n	800123a <Vector16C+0xea>
 8001238:	3304      	adds	r3, #4
    uint32_t w;

    w  = *buf++;
    w |= *buf++ << 8;
 800123a:	f832 1b02 	ldrh.w	r1, [r2], #2
    *pmap++ = (stm32_usb_pma_t)w;
 800123e:	f843 1c04 	str.w	r1, [r3, #-4]
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 8001242:	4298      	cmp	r0, r3
 8001244:	d1f8      	bne.n	8001238 <Vector16C+0xe8>
      isp->txbuf += isp->txlast;
      isp->txlast = n;
      usb_packet_write_from_buffer(ep, isp->txbuf, n);

      /* Starting IN operation.*/
      EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8001246:	6823      	ldr	r3, [r4, #0]
 8001248:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 800124c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001250:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8001254:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001258:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800125c:	6023      	str	r3, [r4, #0]
    else {
      /* Transfer completed, invokes the callback.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if (epr & EPR_CTR_RX) {
 800125e:	f419 4f00 	tst.w	r9, #32768	; 0x8000
 8001262:	d06b      	beq.n	800133c <Vector16C+0x1ec>
    /* OUT endpoint, receive.*/

    EPR_CLEAR_CTR_RX(ep);
 8001264:	6823      	ldr	r3, [r4, #0]
 8001266:	f423 4378 	bic.w	r3, r3, #63488	; 0xf800
 800126a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800126e:	f043 0380 	orr.w	r3, r3, #128	; 0x80

    if (epr & EPR_SETUP) {
 8001272:	f419 6f00 	tst.w	r9, #2048	; 0x800
    }
  }
  if (epr & EPR_CTR_RX) {
    /* OUT endpoint, receive.*/

    EPR_CLEAR_CTR_RX(ep);
 8001276:	6023      	str	r3, [r4, #0]

    if (epr & EPR_SETUP) {
 8001278:	f040 808c 	bne.w	8001394 <Vector16C+0x244>
 *
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800127c:	f8da 3050 	ldr.w	r3, [sl, #80]	; 0x50
      /* Setup packets handling, setup packets are handled using a
         specific callback.*/
      _usb_isr_invoke_setup_cb(usbp, ep);
    }
    else {
      USBOutEndpointState *osp = epcp->out_state;
 8001280:	f8d7 c018 	ldr.w	ip, [r7, #24]
 *
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8001284:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001288:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 800128c:	eb03 1305 	add.w	r3, r3, r5, lsl #4
    }
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
 8001290:	f8dc b008 	ldr.w	fp, [ip, #8]
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8001294:	689a      	ldr	r2, [r3, #8]
  if (EPR_EP_TYPE_IS_ISO(epr) && !(epr & EPR_DTOG_RX))
    n = (size_t)udp->RXCOUNT1 & RXCOUNT_COUNT_MASK;
  else
    n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
#else
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 8001296:	68db      	ldr	r3, [r3, #12]
 8001298:	9301      	str	r3, [sp, #4]
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800129a:	f102 5e00 	add.w	lr, r2, #536870912	; 0x20000000
  if (EPR_EP_TYPE_IS_ISO(epr) && !(epr & EPR_DTOG_RX))
    n = (size_t)udp->RXCOUNT1 & RXCOUNT_COUNT_MASK;
  else
    n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
#else
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 800129e:	f3c3 0909 	ubfx	r9, r3, #0, #10
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 80012a2:	f50e 5e40 	add.w	lr, lr, #12288	; 0x3000
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 80012a6:	f1b9 0f01 	cmp.w	r9, #1
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 80012aa:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 80012ae:	d979      	bls.n	80013a4 <Vector16C+0x254>
 80012b0:	f10b 0202 	add.w	r2, fp, #2
 80012b4:	4649      	mov	r1, r9
 80012b6:	4670      	mov	r0, lr
    uint32_t w = *pmap++;
 80012b8:	f850 3b04 	ldr.w	r3, [r0], #4
    *buf++ = (uint8_t)w;
 80012bc:	f802 3c02 	strb.w	r3, [r2, #-2]
    *buf++ = (uint8_t)(w >> 8);
    i -= 2;
 80012c0:	3902      	subs	r1, #2
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
    uint32_t w = *pmap++;
    *buf++ = (uint8_t)w;
    *buf++ = (uint8_t)(w >> 8);
 80012c2:	0a1b      	lsrs	r3, r3, #8
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 80012c4:	2901      	cmp	r1, #1
    uint32_t w = *pmap++;
    *buf++ = (uint8_t)w;
    *buf++ = (uint8_t)(w >> 8);
 80012c6:	f802 3c01 	strb.w	r3, [r2, #-1]
 80012ca:	f102 0202 	add.w	r2, r2, #2
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 80012ce:	d8f3      	bhi.n	80012b8 <Vector16C+0x168>
 80012d0:	f1a9 0302 	sub.w	r3, r9, #2
 80012d4:	085b      	lsrs	r3, r3, #1
 80012d6:	9a01      	ldr	r2, [sp, #4]
 80012d8:	3301      	adds	r3, #1
 80012da:	f002 0201 	and.w	r2, r2, #1
 80012de:	eb0e 0e83 	add.w	lr, lr, r3, lsl #2
 80012e2:	eb0b 0b43 	add.w	fp, fp, r3, lsl #1
    *buf++ = (uint8_t)w;
    *buf++ = (uint8_t)(w >> 8);
    i -= 2;
  }

  if (i >= 1) {
 80012e6:	b11a      	cbz	r2, 80012f0 <Vector16C+0x1a0>
    *buf = (uint8_t)*pmap;
 80012e8:	f8de 3000 	ldr.w	r3, [lr]
 80012ec:	f88b 3000 	strb.w	r3, [fp]
      osp->rxbuf += n;

      /* Transaction data updated.*/
      osp->rxcnt  += n;
      osp->rxsize -= n;
      osp->rxpkts -= 1;
 80012f0:	f8bc 000c 	ldrh.w	r0, [ip, #12]

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 80012f4:	8a7f      	ldrh	r7, [r7, #18]
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
      osp->rxbuf += n;
 80012f6:	f8dc 3008 	ldr.w	r3, [ip, #8]

      /* Transaction data updated.*/
      osp->rxcnt  += n;
 80012fa:	f8dc 1004 	ldr.w	r1, [ip, #4]
      osp->rxsize -= n;
 80012fe:	f8dc 2000 	ldr.w	r2, [ip]
      osp->rxpkts -= 1;
 8001302:	3801      	subs	r0, #1
 8001304:	b280      	uxth	r0, r0
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
      osp->rxbuf += n;
 8001306:	444b      	add	r3, r9

      /* Transaction data updated.*/
      osp->rxcnt  += n;
 8001308:	4449      	add	r1, r9
      osp->rxsize -= n;
 800130a:	ebc9 0202 	rsb	r2, r9, r2
      osp->rxpkts -= 1;

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 800130e:	454f      	cmp	r7, r9
      osp->rxbuf += n;

      /* Transaction data updated.*/
      osp->rxcnt  += n;
      osp->rxsize -= n;
      osp->rxpkts -= 1;
 8001310:	f8ac 000c 	strh.w	r0, [ip, #12]
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
      osp->rxbuf += n;
 8001314:	f8cc 3008 	str.w	r3, [ip, #8]

      /* Transaction data updated.*/
      osp->rxcnt  += n;
 8001318:	f8cc 1004 	str.w	r1, [ip, #4]
      osp->rxsize -= n;
 800131c:	f8cc 2000 	str.w	r2, [ip]
      osp->rxpkts -= 1;

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 8001320:	d816      	bhi.n	8001350 <Vector16C+0x200>
 8001322:	b1a8      	cbz	r0, 8001350 <Vector16C+0x200>
        /* Transfer complete, invokes the callback.*/
        _usb_isr_invoke_out_cb(usbp, ep);
      }
      else {
        /* Transfer not complete, there are more packets to receive.*/
        EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 8001324:	6823      	ldr	r3, [r4, #0]
 8001326:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 800132a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800132e:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8001332:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001336:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800133a:	6023      	str	r3, [r4, #0]
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
    istr = STM32_USB->ISTR;
 800133c:	f8da 5044 	ldr.w	r5, [sl, #68]	; 0x44
    _usb_isr_invoke_sof_cb(usbp);
    STM32_USB->ISTR = ~ISTR_SOF;
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
 8001340:	042b      	lsls	r3, r5, #16
 8001342:	f53f af30 	bmi.w	80011a6 <Vector16C+0x56>
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
    istr = STM32_USB->ISTR;
  }

  OSAL_IRQ_EPILOGUE();
}
 8001346:	b003      	add	sp, #12
 8001348:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  while (istr & ISTR_CTR) {
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
    istr = STM32_USB->ISTR;
  }

  OSAL_IRQ_EPILOGUE();
 800134c:	f7ff bb48 	b.w	80009e0 <_port_irq_epilogue>

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
        /* Transfer complete, invokes the callback.*/
        _usb_isr_invoke_out_cb(usbp, ep);
 8001350:	eb08 0686 	add.w	r6, r8, r6, lsl #2
 8001354:	f8b8 200a 	ldrh.w	r2, [r8, #10]
 8001358:	6871      	ldr	r1, [r6, #4]
 800135a:	2301      	movs	r3, #1
 800135c:	40ab      	lsls	r3, r5
 800135e:	68cc      	ldr	r4, [r1, #12]
 8001360:	ea22 0303 	bic.w	r3, r2, r3
 8001364:	f8a8 300a 	strh.w	r3, [r8, #10]
 8001368:	2c00      	cmp	r4, #0
 800136a:	d0e7      	beq.n	800133c <Vector16C+0x1ec>
 800136c:	4629      	mov	r1, r5
 800136e:	481d      	ldr	r0, [pc, #116]	; (80013e4 <Vector16C+0x294>)
 8001370:	47a0      	blx	r4
 8001372:	e7e3      	b.n	800133c <Vector16C+0x1ec>
      /* Starting IN operation.*/
      EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
    }
    else {
      /* Transfer completed, invokes the callback.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 8001374:	4b1b      	ldr	r3, [pc, #108]	; (80013e4 <Vector16C+0x294>)
 8001376:	68ba      	ldr	r2, [r7, #8]
 8001378:	891b      	ldrh	r3, [r3, #8]
 800137a:	2101      	movs	r1, #1
 800137c:	40a9      	lsls	r1, r5
 800137e:	ea23 0301 	bic.w	r3, r3, r1
 8001382:	4918      	ldr	r1, [pc, #96]	; (80013e4 <Vector16C+0x294>)
 8001384:	810b      	strh	r3, [r1, #8]
 8001386:	2a00      	cmp	r2, #0
 8001388:	f43f af69 	beq.w	800125e <Vector16C+0x10e>
 800138c:	4629      	mov	r1, r5
 800138e:	4815      	ldr	r0, [pc, #84]	; (80013e4 <Vector16C+0x294>)
 8001390:	4790      	blx	r2
 8001392:	e764      	b.n	800125e <Vector16C+0x10e>
    EPR_CLEAR_CTR_RX(ep);

    if (epr & EPR_SETUP) {
      /* Setup packets handling, setup packets are handled using a
         specific callback.*/
      _usb_isr_invoke_setup_cb(usbp, ep);
 8001394:	eb08 0686 	add.w	r6, r8, r6, lsl #2
 8001398:	4629      	mov	r1, r5
 800139a:	6873      	ldr	r3, [r6, #4]
 800139c:	4811      	ldr	r0, [pc, #68]	; (80013e4 <Vector16C+0x294>)
 800139e:	685b      	ldr	r3, [r3, #4]
 80013a0:	4798      	blx	r3
 80013a2:	e7cb      	b.n	800133c <Vector16C+0x1ec>
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 80013a4:	464a      	mov	r2, r9
 80013a6:	e79e      	b.n	80012e6 <Vector16C+0x196>
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 80013a8:	f8df 8038 	ldr.w	r8, [pc, #56]	; 80013e4 <Vector16C+0x294>
    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
    STM32_USB->CNTR |= CNTR_FSUSP;
 80013ac:	4b0c      	ldr	r3, [pc, #48]	; (80013e0 <Vector16C+0x290>)
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80013ae:	f8d8 1004 	ldr.w	r1, [r8, #4]
 80013b2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80013b4:	680c      	ldr	r4, [r1, #0]
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 80013b6:	f898 0000 	ldrb.w	r0, [r8]
 80013ba:	f042 0208 	orr.w	r2, r2, #8
#if STM32_USB_LOW_POWER_ON_SUSPEND
    STM32_USB->CNTR |= CNTR_LP_MODE;
#endif
    STM32_USB->ISTR = ~ISTR_SUSP;
 80013be:	f46f 6600 	mvn.w	r6, #2048	; 0x800
  usbp->state       = USB_SUSPENDED;
 80013c2:	2105      	movs	r1, #5
    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
    STM32_USB->CNTR |= CNTR_FSUSP;
 80013c4:	641a      	str	r2, [r3, #64]	; 0x40
#if STM32_USB_LOW_POWER_ON_SUSPEND
    STM32_USB->CNTR |= CNTR_LP_MODE;
#endif
    STM32_USB->ISTR = ~ISTR_SUSP;
 80013c6:	645e      	str	r6, [r3, #68]	; 0x44
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 80013c8:	f888 0080 	strb.w	r0, [r8, #128]	; 0x80
  usbp->state       = USB_SUSPENDED;
 80013cc:	f888 1000 	strb.w	r1, [r8]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80013d0:	2c00      	cmp	r4, #0
 80013d2:	f43f aec8 	beq.w	8001166 <Vector16C+0x16>
 80013d6:	4640      	mov	r0, r8
 80013d8:	2104      	movs	r1, #4
 80013da:	47a0      	blx	r4
 80013dc:	e6c3      	b.n	8001166 <Vector16C+0x16>
 80013de:	bf00      	nop
 80013e0:	40005c00 	.word	0x40005c00
 80013e4:	20000a48 	.word	0x20000a48
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 80013e8:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 80014d8 <Vector16C+0x388>

  /* Resetting internal state.*/
  usbp->status        = 0;
 80013ec:	2200      	movs	r2, #0

  istr = STM32_USB->ISTR;

  /* USB bus reset condition handling.*/
  if (istr & ISTR_RESET) {
    STM32_USB->ISTR = ~ISTR_RESET;
 80013ee:	f46f 6080 	mvn.w	r0, #1024	; 0x400
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 80013f2:	2102      	movs	r1, #2
 80013f4:	6458      	str	r0, [r3, #68]	; 0x44
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 80013f6:	4610      	mov	r0, r2

  /* State transition.*/
  usbp->state         = USB_READY;

  /* Resetting internal state.*/
  usbp->status        = 0;
 80013f8:	f8a8 207c 	strh.w	r2, [r8, #124]	; 0x7c
  usbp->address       = 0;
 80013fc:	f888 207e 	strb.w	r2, [r8, #126]	; 0x7e
  usbp->configuration = 0;
 8001400:	f888 207f 	strb.w	r2, [r8, #127]	; 0x7f
  usbp->transmitting  = 0;
 8001404:	f8a8 2008 	strh.w	r2, [r8, #8]
  usbp->receiving     = 0;
 8001408:	f8a8 200a 	strh.w	r2, [r8, #10]
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 800140c:	f888 1000 	strb.w	r1, [r8]
 8001410:	f108 0308 	add.w	r3, r8, #8
 8001414:	f108 0228 	add.w	r2, r8, #40	; 0x28
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8001418:	f843 0f04 	str.w	r0, [r3, #4]!
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800141c:	429a      	cmp	r2, r3
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 800141e:	f04f 0100 	mov.w	r1, #0
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8001422:	d1f9      	bne.n	8001418 <Vector16C+0x2c8>
  STM32_USB->DADDR  = DADDR_EF;
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
 8001424:	f8d8 0004 	ldr.w	r0, [r8, #4]
 */
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
 8001428:	4a29      	ldr	r2, [pc, #164]	; (80014d0 <Vector16C+0x380>)
  STM32_USB->DADDR  = DADDR_EF;
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
 800142a:	68c3      	ldr	r3, [r0, #12]
#endif
    usbp->epc[i] = NULL;
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800142c:	f888 1064 	strb.w	r1, [r8, #100]	; 0x64
    cntr |= CNTR_SOFM;
 8001430:	428b      	cmp	r3, r1
 8001432:	bf0c      	ite	eq
 8001434:	f44f 441c 	moveq.w	r4, #39936	; 0x9c00
 8001438:	f44f 441e 	movne.w	r4, #40448	; 0x9e00
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
  STM32_USB->ISTR   = 0;
  STM32_USB->DADDR  = DADDR_EF;
 800143c:	2680      	movs	r6, #128	; 0x80
 */
static void usb_pm_reset(USBDriver *usbp) {

  /* The first 64 bytes are reserved for the descriptors table. The effective
     available RAM for endpoint buffers is just 448 bytes.*/
  usbp->pmnext = 64;
 800143e:	2340      	movs	r3, #64	; 0x40
 */
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
 8001440:	6511      	str	r1, [r2, #80]	; 0x50
  STM32_USB->ISTR   = 0;
 8001442:	6451      	str	r1, [r2, #68]	; 0x44
  STM32_USB->DADDR  = DADDR_EF;
 8001444:	64d6      	str	r6, [r2, #76]	; 0x4c
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
    cntr |= CNTR_SOFM;
  STM32_USB->CNTR = cntr;
 8001446:	6414      	str	r4, [r2, #64]	; 0x40
 */
static void usb_pm_reset(USBDriver *usbp) {

  /* The first 64 bytes are reserved for the descriptors table. The effective
     available RAM for endpoint buffers is just 448 bytes.*/
  usbp->pmnext = 64;
 8001448:	f8c8 3084 	str.w	r3, [r8, #132]	; 0x84
    break;
  default:
    epr = EPR_EP_TYPE_CONTROL;
  }

  dp = USB_GET_DESCRIPTOR(ep);
 800144c:	6d13      	ldr	r3, [r2, #80]	; 0x50

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
 800144e:	4c21      	ldr	r4, [pc, #132]	; (80014d4 <Vector16C+0x384>)
 8001450:	f8c8 400c 	str.w	r4, [r8, #12]
    break;
  default:
    epr = EPR_EP_TYPE_CONTROL;
  }

  dp = USB_GET_DESCRIPTOR(ep);
 8001454:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001458:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000

  /* Low level reset.*/
  usb_lld_reset(usbp);

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 800145c:	6804      	ldr	r4, [r0, #0]

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
    dp->TXCOUNT0 = 0;
 800145e:	6059      	str	r1, [r3, #4]
 * @param[in] size      size of the packet buffer to allocate
 */
static uint32_t usb_pm_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 8001460:	f8d8 0084 	ldr.w	r0, [r8, #132]	; 0x84
    if (epcp->out_maxsize > 62)
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
                0x8000;
    else
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
    dp->RXCOUNT0 = nblocks;
 8001464:	f44f 4608 	mov.w	r6, #34816	; 0x8800
 */
static uint32_t usb_pm_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += (size + 1) & ~1;
 8001468:	f100 0740 	add.w	r7, r0, #64	; 0x40
 800146c:	f8c8 7084 	str.w	r7, [r8, #132]	; 0x84
  dp = USB_GET_DESCRIPTOR(ep);

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
    dp->TXCOUNT0 = 0;
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8001470:	6018      	str	r0, [r3, #0]
    if (epcp->out_maxsize > 62)
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
                0x8000;
    else
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
    dp->RXCOUNT0 = nblocks;
 8001472:	60de      	str	r6, [r3, #12]
 * @param[in] size      size of the packet buffer to allocate
 */
static uint32_t usb_pm_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 8001474:	f8d8 0084 	ldr.w	r0, [r8, #132]	; 0x84
    epr |= EPR_STAT_RX_NAK;
#endif
  }

  /* EPxR register setup.*/
  EPR_SET(ep, epr | ep);
 8001478:	f248 2680 	movw	r6, #33408	; 0x8280
 */
static uint32_t usb_pm_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += (size + 1) & ~1;
 800147c:	f100 0740 	add.w	r7, r0, #64	; 0x40
 8001480:	f8c8 7084 	str.w	r7, [r8, #132]	; 0x84
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
                0x8000;
    else
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
    dp->RXCOUNT0 = nblocks;
    dp->RXADDR0  = usb_pm_alloc(usbp, epcp->out_maxsize);
 8001484:	6098      	str	r0, [r3, #8]
    epr |= EPR_STAT_RX_NAK;
#endif
  }

  /* EPxR register setup.*/
  EPR_SET(ep, epr | ep);
 8001486:	6016      	str	r6, [r2, #0]
  EPR_TOGGLE(ep, epr);
 8001488:	6813      	ldr	r3, [r2, #0]
 800148a:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 800148e:	f083 0320 	eor.w	r3, r3, #32
 8001492:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001496:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800149a:	6013      	str	r3, [r2, #0]
 800149c:	2c00      	cmp	r4, #0
 800149e:	f43f ae5f 	beq.w	8001160 <Vector16C+0x10>
 80014a2:	480d      	ldr	r0, [pc, #52]	; (80014d8 <Vector16C+0x388>)
 80014a4:	47a0      	blx	r4
 80014a6:	e65b      	b.n	8001160 <Vector16C+0x10>
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 80014a8:	f8df 802c 	ldr.w	r8, [pc, #44]	; 80014d8 <Vector16C+0x388>

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
    uint32_t fnr = STM32_USB->FNR;
    if (!(fnr & FNR_RXDP)) {
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 80014ac:	6c1a      	ldr	r2, [r3, #64]	; 0x40

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80014ae:	f8d8 0004 	ldr.w	r0, [r8, #4]
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 80014b2:	f898 1080 	ldrb.w	r1, [r8, #128]	; 0x80

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80014b6:	6804      	ldr	r4, [r0, #0]
 80014b8:	f022 0208 	bic.w	r2, r2, #8
 80014bc:	641a      	str	r2, [r3, #64]	; 0x40
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 80014be:	f888 1000 	strb.w	r1, [r8]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80014c2:	2c00      	cmp	r4, #0
 80014c4:	f43f ae56 	beq.w	8001174 <Vector16C+0x24>
 80014c8:	4640      	mov	r0, r8
 80014ca:	2105      	movs	r1, #5
 80014cc:	47a0      	blx	r4
 80014ce:	e651      	b.n	8001174 <Vector16C+0x24>
 80014d0:	40005c00 	.word	0x40005c00
 80014d4:	08002c60 	.word	0x08002c60
 80014d8:	20000a48 	.word	0x20000a48
 80014dc:	00000000 	.word	0x00000000

080014e0 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 80014e0:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 80014e2:	4d17      	ldr	r5, [pc, #92]	; (8001540 <VectorB8+0x60>)
 80014e4:	69ab      	ldr	r3, [r5, #24]
 80014e6:	691c      	ldr	r4, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 80014e8:	68da      	ldr	r2, [r3, #12]
 80014ea:	4014      	ands	r4, r2
  pwmp->tim->SR = ~sr;
 80014ec:	b2e2      	uxtb	r2, r4
 80014ee:	43d2      	mvns	r2, r2
 80014f0:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80014f2:	07a3      	lsls	r3, r4, #30
 80014f4:	d504      	bpl.n	8001500 <VectorB8+0x20>
      (pwmp->config->channels[0].callback != NULL))
 80014f6:	686b      	ldr	r3, [r5, #4]
 80014f8:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80014fa:	b10b      	cbz	r3, 8001500 <VectorB8+0x20>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 80014fc:	4628      	mov	r0, r5
 80014fe:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8001500:	0760      	lsls	r0, r4, #29
 8001502:	d504      	bpl.n	800150e <VectorB8+0x2e>
      (pwmp->config->channels[1].callback != NULL))
 8001504:	686b      	ldr	r3, [r5, #4]
 8001506:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8001508:	b10b      	cbz	r3, 800150e <VectorB8+0x2e>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 800150a:	480d      	ldr	r0, [pc, #52]	; (8001540 <VectorB8+0x60>)
 800150c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800150e:	0721      	lsls	r1, r4, #28
 8001510:	d504      	bpl.n	800151c <VectorB8+0x3c>
      (pwmp->config->channels[2].callback != NULL))
 8001512:	686b      	ldr	r3, [r5, #4]
 8001514:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8001516:	b10b      	cbz	r3, 800151c <VectorB8+0x3c>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 8001518:	4809      	ldr	r0, [pc, #36]	; (8001540 <VectorB8+0x60>)
 800151a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800151c:	06e2      	lsls	r2, r4, #27
 800151e:	d504      	bpl.n	800152a <VectorB8+0x4a>
      (pwmp->config->channels[3].callback != NULL))
 8001520:	686b      	ldr	r3, [r5, #4]
 8001522:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8001524:	b10b      	cbz	r3, 800152a <VectorB8+0x4a>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 8001526:	4806      	ldr	r0, [pc, #24]	; (8001540 <VectorB8+0x60>)
 8001528:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 800152a:	07e3      	lsls	r3, r4, #31
 800152c:	d504      	bpl.n	8001538 <VectorB8+0x58>
 800152e:	686b      	ldr	r3, [r5, #4]
 8001530:	689b      	ldr	r3, [r3, #8]
 8001532:	b10b      	cbz	r3, 8001538 <VectorB8+0x58>
    pwmp->config->callback(pwmp);
 8001534:	4802      	ldr	r0, [pc, #8]	; (8001540 <VectorB8+0x60>)
 8001536:	4798      	blx	r3
  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD4);

  OSAL_IRQ_EPILOGUE();
}
 8001538:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD4);

  OSAL_IRQ_EPILOGUE();
 800153c:	f7ff ba50 	b.w	80009e0 <_port_irq_epilogue>
 8001540:	20000a2c 	.word	0x20000a2c
	...

08001550 <VectorA4>:
/**
 * @brief   TIM1 compare interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8001550:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
void icu_lld_serve_interrupt(ICUDriver *icup) {
  uint32_t sr;

  sr  = icup->tim->SR;
 8001552:	4d25      	ldr	r5, [pc, #148]	; (80015e8 <VectorA4+0x98>)
 8001554:	68eb      	ldr	r3, [r5, #12]
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  icup->tim->SR = ~sr;
  if (icup->config->channel == ICU_CHANNEL_1) {
 8001556:	6869      	ldr	r1, [r5, #4]
 * @notapi
 */
void icu_lld_serve_interrupt(ICUDriver *icup) {
  uint32_t sr;

  sr  = icup->tim->SR;
 8001558:	691c      	ldr	r4, [r3, #16]
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 800155a:	68da      	ldr	r2, [r3, #12]
  icup->tim->SR = ~sr;
  if (icup->config->channel == ICU_CHANNEL_1) {
 800155c:	7d08      	ldrb	r0, [r1, #20]
 800155e:	4014      	ands	r4, r2
void icu_lld_serve_interrupt(ICUDriver *icup) {
  uint32_t sr;

  sr  = icup->tim->SR;
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  icup->tim->SR = ~sr;
 8001560:	b2e2      	uxtb	r2, r4
 8001562:	43d2      	mvns	r2, r2
 8001564:	611a      	str	r2, [r3, #16]
  if (icup->config->channel == ICU_CHANNEL_1) {
 8001566:	b990      	cbnz	r0, 800158e <VectorA4+0x3e>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 8001568:	0760      	lsls	r0, r4, #29
 800156a:	d52f      	bpl.n	80015cc <VectorA4+0x7c>
      _icu_isr_invoke_width_cb(icup);
 800156c:	782b      	ldrb	r3, [r5, #0]
 800156e:	2b04      	cmp	r3, #4
 8001570:	d028      	beq.n	80015c4 <VectorA4+0x74>
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 8001572:	07a1      	lsls	r1, r4, #30
 8001574:	d412      	bmi.n	800159c <VectorA4+0x4c>
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
      _icu_isr_invoke_width_cb(icup);
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
      _icu_isr_invoke_period_cb(icup);
  }
  if ((sr & STM32_TIM_SR_UIF) != 0)
 8001576:	07e4      	lsls	r4, r4, #31
 8001578:	d505      	bpl.n	8001586 <VectorA4+0x36>
    _icu_isr_invoke_overflow_cb(icup);
 800157a:	686b      	ldr	r3, [r5, #4]
 800157c:	481a      	ldr	r0, [pc, #104]	; (80015e8 <VectorA4+0x98>)
 800157e:	691b      	ldr	r3, [r3, #16]
 8001580:	4798      	blx	r3
 8001582:	2303      	movs	r3, #3
 8001584:	702b      	strb	r3, [r5, #0]
  OSAL_IRQ_PROLOGUE();

  icu_lld_serve_interrupt(&ICUD1);

  OSAL_IRQ_EPILOGUE();
}
 8001586:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  icu_lld_serve_interrupt(&ICUD1);

  OSAL_IRQ_EPILOGUE();
 800158a:	f7ff ba29 	b.w	80009e0 <_port_irq_epilogue>
      _icu_isr_invoke_width_cb(icup);
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
      _icu_isr_invoke_period_cb(icup);
  }
  else {
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 800158e:	07a2      	lsls	r2, r4, #30
 8001590:	d50b      	bpl.n	80015aa <VectorA4+0x5a>
      _icu_isr_invoke_width_cb(icup);
 8001592:	782b      	ldrb	r3, [r5, #0]
 8001594:	2b04      	cmp	r3, #4
 8001596:	d004      	beq.n	80015a2 <VectorA4+0x52>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 8001598:	0763      	lsls	r3, r4, #29
 800159a:	d5ec      	bpl.n	8001576 <VectorA4+0x26>
  icup->tim->SR = ~sr;
  if (icup->config->channel == ICU_CHANNEL_1) {
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
      _icu_isr_invoke_width_cb(icup);
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
      _icu_isr_invoke_period_cb(icup);
 800159c:	2304      	movs	r3, #4
 800159e:	702b      	strb	r3, [r5, #0]
 80015a0:	e7e9      	b.n	8001576 <VectorA4+0x26>
  }
  else {
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
      _icu_isr_invoke_width_cb(icup);
 80015a2:	688b      	ldr	r3, [r1, #8]
 80015a4:	b1e3      	cbz	r3, 80015e0 <VectorA4+0x90>
 80015a6:	4628      	mov	r0, r5
 80015a8:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 80015aa:	0763      	lsls	r3, r4, #29
 80015ac:	d5e3      	bpl.n	8001576 <VectorA4+0x26>
  icup->tim->SR = ~sr;
  if (icup->config->channel == ICU_CHANNEL_1) {
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
      _icu_isr_invoke_width_cb(icup);
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
      _icu_isr_invoke_period_cb(icup);
 80015ae:	782b      	ldrb	r3, [r5, #0]
 80015b0:	4a0d      	ldr	r2, [pc, #52]	; (80015e8 <VectorA4+0x98>)
 80015b2:	2b04      	cmp	r3, #4
 80015b4:	d1f2      	bne.n	800159c <VectorA4+0x4c>
 80015b6:	6851      	ldr	r1, [r2, #4]
 80015b8:	68cb      	ldr	r3, [r1, #12]
 80015ba:	2b00      	cmp	r3, #0
 80015bc:	d0ee      	beq.n	800159c <VectorA4+0x4c>
 80015be:	480a      	ldr	r0, [pc, #40]	; (80015e8 <VectorA4+0x98>)
 80015c0:	4798      	blx	r3
 80015c2:	e7eb      	b.n	800159c <VectorA4+0x4c>
  sr  = icup->tim->SR;
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  icup->tim->SR = ~sr;
  if (icup->config->channel == ICU_CHANNEL_1) {
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
      _icu_isr_invoke_width_cb(icup);
 80015c4:	688b      	ldr	r3, [r1, #8]
 80015c6:	b143      	cbz	r3, 80015da <VectorA4+0x8a>
 80015c8:	4628      	mov	r0, r5
 80015ca:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80015cc:	07a1      	lsls	r1, r4, #30
 80015ce:	d5d2      	bpl.n	8001576 <VectorA4+0x26>
      _icu_isr_invoke_period_cb(icup);
 80015d0:	782b      	ldrb	r3, [r5, #0]
 80015d2:	4a05      	ldr	r2, [pc, #20]	; (80015e8 <VectorA4+0x98>)
 80015d4:	2b04      	cmp	r3, #4
 80015d6:	d1e1      	bne.n	800159c <VectorA4+0x4c>
 80015d8:	e7ed      	b.n	80015b6 <VectorA4+0x66>
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  icup->tim->SR = ~sr;
  if (icup->config->channel == ICU_CHANNEL_1) {
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
      _icu_isr_invoke_width_cb(icup);
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80015da:	07a0      	lsls	r0, r4, #30
 80015dc:	d4ec      	bmi.n	80015b8 <VectorA4+0x68>
 80015de:	e7ca      	b.n	8001576 <VectorA4+0x26>
      _icu_isr_invoke_period_cb(icup);
  }
  else {
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
      _icu_isr_invoke_width_cb(icup);
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 80015e0:	0762      	lsls	r2, r4, #29
 80015e2:	d4e9      	bmi.n	80015b8 <VectorA4+0x68>
 80015e4:	e7c7      	b.n	8001576 <VectorA4+0x26>
 80015e6:	bf00      	nop
 80015e8:	20001080 	.word	0x20001080
 80015ec:	00000000 	.word	0x00000000

080015f0 <VectorAC>:
 80015f0:	f7ff bfae 	b.w	8001550 <VectorA4>
	...

08001600 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001600:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001604:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
 8001608:	6933      	ldr	r3, [r6, #16]
 800160a:	079b      	lsls	r3, r3, #30
 800160c:	d403      	bmi.n	8001616 <VectorB0+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 800160e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8001612:	f7ff b9e5 	b.w	80009e0 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8001616:	2500      	movs	r5, #0
 8001618:	6135      	str	r5, [r6, #16]
 800161a:	2720      	movs	r7, #32
 800161c:	f387 8811 	msr	BASEPRI, r7
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8001620:	4c1b      	ldr	r4, [pc, #108]	; (8001690 <VectorB0+0x90>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001622:	6a71      	ldr	r1, [r6, #36]	; 0x24
 8001624:	69e3      	ldr	r3, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8001626:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001628:	f8d3 e008 	ldr.w	lr, [r3, #8]
 800162c:	1a88      	subs	r0, r1, r2
 800162e:	4570      	cmp	r0, lr
 8001630:	f104 081c 	add.w	r8, r4, #28
 8001634:	d319      	bcc.n	800166a <VectorB0+0x6a>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001636:	6819      	ldr	r1, [r3, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 8001638:	f8d3 900c 	ldr.w	r9, [r3, #12]
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 800163c:	4472      	add	r2, lr
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800163e:	4541      	cmp	r1, r8
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8001640:	62a2      	str	r2, [r4, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001642:	f8c1 8004 	str.w	r8, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8001646:	61e1      	str	r1, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 8001648:	60dd      	str	r5, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800164a:	bf08      	it	eq
 800164c:	60f5      	streq	r5, [r6, #12]
 800164e:	f385 8811 	msr	BASEPRI, r5
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8001652:	6918      	ldr	r0, [r3, #16]
 8001654:	47c8      	blx	r9
 8001656:	f387 8811 	msr	BASEPRI, r7
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 800165a:	69e3      	ldr	r3, [r4, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800165c:	6a71      	ldr	r1, [r6, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 800165e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001660:	f8d3 e008 	ldr.w	lr, [r3, #8]
 8001664:	1a88      	subs	r0, r1, r2
 8001666:	4586      	cmp	lr, r0
 8001668:	d9e5      	bls.n	8001636 <VectorB0+0x36>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800166a:	4543      	cmp	r3, r8
 800166c:	d008      	beq.n	8001680 <VectorB0+0x80>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 800166e:	4472      	add	r2, lr
 8001670:	1a52      	subs	r2, r2, r1
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001672:	2a01      	cmp	r2, #1
 8001674:	bf98      	it	ls
 8001676:	2202      	movls	r2, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001678:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  }
  port_timer_set_alarm(now + delta);
 800167c:	440a      	add	r2, r1
 800167e:	635a      	str	r2, [r3, #52]	; 0x34
 8001680:	2300      	movs	r3, #0
 8001682:	f383 8811 	msr	BASEPRI, r3
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8001686:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 800168a:	f7ff b9a9 	b.w	80009e0 <_port_irq_epilogue>
 800168e:	bf00      	nop
 8001690:	20001178 	.word	0x20001178
	...

080016a0 <Vector130>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 80016a0:	4b0b      	ldr	r3, [pc, #44]	; (80016d0 <Vector130+0x30>)
 80016a2:	4a0c      	ldr	r2, [pc, #48]	; (80016d4 <Vector130+0x34>)
 80016a4:	6819      	ldr	r1, [r3, #0]
 80016a6:	6812      	ldr	r2, [r2, #0]
 80016a8:	0c09      	lsrs	r1, r1, #16
 80016aa:	f001 010e 	and.w	r1, r1, #14
 80016ae:	4211      	tst	r1, r2
 80016b0:	d00b      	beq.n	80016ca <Vector130+0x2a>
 80016b2:	4809      	ldr	r0, [pc, #36]	; (80016d8 <Vector130+0x38>)
 80016b4:	6d82      	ldr	r2, [r0, #88]	; 0x58
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 80016b6:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 80016b8:	040c      	lsls	r4, r1, #16
 80016ba:	605c      	str	r4, [r3, #4]
 80016bc:	b10a      	cbz	r2, 80016c2 <Vector130+0x22>
 80016be:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 80016c0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80016c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM5);

  OSAL_IRQ_EPILOGUE();
 80016c6:	f7ff b98b 	b.w	80009e0 <_port_irq_epilogue>
 80016ca:	f7ff b989 	b.w	80009e0 <_port_irq_epilogue>
 80016ce:	bf00      	nop
 80016d0:	40020400 	.word	0x40020400
 80016d4:	40020458 	.word	0x40020458
 80016d8:	20001098 	.word	0x20001098
 80016dc:	00000000 	.word	0x00000000

080016e0 <Vector12C>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 80016e0:	4b0b      	ldr	r3, [pc, #44]	; (8001710 <Vector12C+0x30>)
 80016e2:	4a0c      	ldr	r2, [pc, #48]	; (8001714 <Vector12C+0x34>)
 80016e4:	6819      	ldr	r1, [r3, #0]
 80016e6:	6812      	ldr	r2, [r2, #0]
 80016e8:	0b09      	lsrs	r1, r1, #12
 80016ea:	f001 010e 	and.w	r1, r1, #14
 80016ee:	4211      	tst	r1, r2
 80016f0:	d00b      	beq.n	800170a <Vector12C+0x2a>
 80016f2:	4809      	ldr	r0, [pc, #36]	; (8001718 <Vector12C+0x38>)
 80016f4:	6d02      	ldr	r2, [r0, #80]	; 0x50
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 80016f6:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 80016f8:	030c      	lsls	r4, r1, #12
 80016fa:	605c      	str	r4, [r3, #4]
 80016fc:	b10a      	cbz	r2, 8001702 <Vector12C+0x22>
 80016fe:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8001700:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001702:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM4);

  OSAL_IRQ_EPILOGUE();
 8001706:	f7ff b96b 	b.w	80009e0 <_port_irq_epilogue>
 800170a:	f7ff b969 	b.w	80009e0 <_port_irq_epilogue>
 800170e:	bf00      	nop
 8001710:	40020400 	.word	0x40020400
 8001714:	40020444 	.word	0x40020444
 8001718:	20001098 	.word	0x20001098
 800171c:	00000000 	.word	0x00000000

08001720 <Vector128>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8001720:	4b0b      	ldr	r3, [pc, #44]	; (8001750 <Vector128+0x30>)
 8001722:	4a0c      	ldr	r2, [pc, #48]	; (8001754 <Vector128+0x34>)
 8001724:	6819      	ldr	r1, [r3, #0]
 8001726:	6812      	ldr	r2, [r2, #0]
 8001728:	0a09      	lsrs	r1, r1, #8
 800172a:	f001 010e 	and.w	r1, r1, #14
 800172e:	4211      	tst	r1, r2
 8001730:	d00b      	beq.n	800174a <Vector128+0x2a>
 8001732:	4809      	ldr	r0, [pc, #36]	; (8001758 <Vector128+0x38>)
 8001734:	6c82      	ldr	r2, [r0, #72]	; 0x48
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8001736:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8001738:	020c      	lsls	r4, r1, #8
 800173a:	605c      	str	r4, [r3, #4]
 800173c:	b10a      	cbz	r2, 8001742 <Vector128+0x22>
 800173e:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8001740:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001742:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);

  OSAL_IRQ_EPILOGUE();
 8001746:	f7ff b94b 	b.w	80009e0 <_port_irq_epilogue>
 800174a:	f7ff b949 	b.w	80009e0 <_port_irq_epilogue>
 800174e:	bf00      	nop
 8001750:	40020400 	.word	0x40020400
 8001754:	40020430 	.word	0x40020430
 8001758:	20001098 	.word	0x20001098
 800175c:	00000000 	.word	0x00000000

08001760 <Vector124>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 8001760:	4b0b      	ldr	r3, [pc, #44]	; (8001790 <Vector124+0x30>)
 8001762:	4a0c      	ldr	r2, [pc, #48]	; (8001794 <Vector124+0x34>)
 8001764:	6819      	ldr	r1, [r3, #0]
 8001766:	6812      	ldr	r2, [r2, #0]
 8001768:	0909      	lsrs	r1, r1, #4
 800176a:	f001 010e 	and.w	r1, r1, #14
 800176e:	4211      	tst	r1, r2
 8001770:	d00b      	beq.n	800178a <Vector124+0x2a>
 8001772:	4809      	ldr	r0, [pc, #36]	; (8001798 <Vector124+0x38>)
 8001774:	6c02      	ldr	r2, [r0, #64]	; 0x40
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8001776:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 8001778:	010c      	lsls	r4, r1, #4
 800177a:	605c      	str	r4, [r3, #4]
 800177c:	b10a      	cbz	r2, 8001782 <Vector124+0x22>
 800177e:	6c40      	ldr	r0, [r0, #68]	; 0x44
 8001780:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001782:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);

  OSAL_IRQ_EPILOGUE();
 8001786:	f7ff b92b 	b.w	80009e0 <_port_irq_epilogue>
 800178a:	f7ff b929 	b.w	80009e0 <_port_irq_epilogue>
 800178e:	bf00      	nop
 8001790:	40020400 	.word	0x40020400
 8001794:	4002041c 	.word	0x4002041c
 8001798:	20001098 	.word	0x20001098
 800179c:	00000000 	.word	0x00000000

080017a0 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 80017a0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 80017a2:	4b09      	ldr	r3, [pc, #36]	; (80017c8 <Vector120+0x28>)
 80017a4:	4a09      	ldr	r2, [pc, #36]	; (80017cc <Vector120+0x2c>)
 80017a6:	6819      	ldr	r1, [r3, #0]
 80017a8:	6812      	ldr	r2, [r2, #0]
 80017aa:	f001 010e 	and.w	r1, r1, #14
 80017ae:	4211      	tst	r1, r2
 80017b0:	d005      	beq.n	80017be <Vector120+0x1e>
 80017b2:	4a07      	ldr	r2, [pc, #28]	; (80017d0 <Vector120+0x30>)
 80017b4:	6059      	str	r1, [r3, #4]
 80017b6:	6b93      	ldr	r3, [r2, #56]	; 0x38
 80017b8:	b10b      	cbz	r3, 80017be <Vector120+0x1e>
 80017ba:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 80017bc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80017be:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);

  OSAL_IRQ_EPILOGUE();
 80017c2:	f7ff b90d 	b.w	80009e0 <_port_irq_epilogue>
 80017c6:	bf00      	nop
 80017c8:	40020400 	.word	0x40020400
 80017cc:	40020408 	.word	0x40020408
 80017d0:	20001098 	.word	0x20001098
	...

080017e0 <Vector84>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 80017e0:	4b0b      	ldr	r3, [pc, #44]	; (8001810 <Vector84+0x30>)
 80017e2:	4a0c      	ldr	r2, [pc, #48]	; (8001814 <Vector84+0x34>)
 80017e4:	6819      	ldr	r1, [r3, #0]
 80017e6:	6812      	ldr	r2, [r2, #0]
 80017e8:	0e09      	lsrs	r1, r1, #24
 80017ea:	f001 010e 	and.w	r1, r1, #14
 80017ee:	4211      	tst	r1, r2
 80017f0:	d00b      	beq.n	800180a <Vector84+0x2a>
 80017f2:	4809      	ldr	r0, [pc, #36]	; (8001818 <Vector84+0x38>)
 80017f4:	6b02      	ldr	r2, [r0, #48]	; 0x30
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 80017f6:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 80017f8:	060c      	lsls	r4, r1, #24
 80017fa:	605c      	str	r4, [r3, #4]
 80017fc:	b10a      	cbz	r2, 8001802 <Vector84+0x22>
 80017fe:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8001800:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001802:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);

  OSAL_IRQ_EPILOGUE();
 8001806:	f7ff b8eb 	b.w	80009e0 <_port_irq_epilogue>
 800180a:	f7ff b8e9 	b.w	80009e0 <_port_irq_epilogue>
 800180e:	bf00      	nop
 8001810:	40020000 	.word	0x40020000
 8001814:	40020080 	.word	0x40020080
 8001818:	20001098 	.word	0x20001098
 800181c:	00000000 	.word	0x00000000

08001820 <Vector80>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8001820:	4b0b      	ldr	r3, [pc, #44]	; (8001850 <Vector80+0x30>)
 8001822:	4a0c      	ldr	r2, [pc, #48]	; (8001854 <Vector80+0x34>)
 8001824:	6819      	ldr	r1, [r3, #0]
 8001826:	6812      	ldr	r2, [r2, #0]
 8001828:	0d09      	lsrs	r1, r1, #20
 800182a:	f001 010e 	and.w	r1, r1, #14
 800182e:	4211      	tst	r1, r2
 8001830:	d00b      	beq.n	800184a <Vector80+0x2a>
 8001832:	4809      	ldr	r0, [pc, #36]	; (8001858 <Vector80+0x38>)
 8001834:	6a82      	ldr	r2, [r0, #40]	; 0x28
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8001836:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8001838:	050c      	lsls	r4, r1, #20
 800183a:	605c      	str	r4, [r3, #4]
 800183c:	b10a      	cbz	r2, 8001842 <Vector80+0x22>
 800183e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8001840:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001842:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);

  OSAL_IRQ_EPILOGUE();
 8001846:	f7ff b8cb 	b.w	80009e0 <_port_irq_epilogue>
 800184a:	f7ff b8c9 	b.w	80009e0 <_port_irq_epilogue>
 800184e:	bf00      	nop
 8001850:	40020000 	.word	0x40020000
 8001854:	4002006c 	.word	0x4002006c
 8001858:	20001098 	.word	0x20001098
 800185c:	00000000 	.word	0x00000000

08001860 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001860:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8001864:	4d61      	ldr	r5, [pc, #388]	; (80019ec <VectorD4+0x18c>)
 8001866:	6f6e      	ldr	r6, [r5, #116]	; 0x74
  uint32_t cr1 = u->CR1;
 8001868:	6837      	ldr	r7, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800186a:	69f4      	ldr	r4, [r6, #28]
  u->ICR = isr;
 800186c:	6234      	str	r4, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800186e:	0722      	lsls	r2, r4, #28
 8001870:	d153      	bne.n	800191a <VectorD4+0xba>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8001872:	05e3      	lsls	r3, r4, #23
 8001874:	d446      	bmi.n	8001904 <VectorD4+0xa4>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8001876:	06a0      	lsls	r0, r4, #26
 8001878:	d418      	bmi.n	80018ac <VectorD4+0x4c>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 800187a:	0639      	lsls	r1, r7, #24
 800187c:	d501      	bpl.n	8001882 <VectorD4+0x22>
 800187e:	0622      	lsls	r2, r4, #24
 8001880:	d465      	bmi.n	800194e <VectorD4+0xee>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8001882:	0663      	lsls	r3, r4, #25
 8001884:	d50e      	bpl.n	80018a4 <VectorD4+0x44>
 8001886:	2320      	movs	r3, #32
 8001888:	f383 8811 	msr	BASEPRI, r3
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800188c:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 800188e:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8001890:	4956      	ldr	r1, [pc, #344]	; (80019ec <VectorD4+0x18c>)
 8001892:	429a      	cmp	r2, r3
 8001894:	f000 8089 	beq.w	80019aa <VectorD4+0x14a>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001898:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 800189c:	6037      	str	r7, [r6, #0]
 800189e:	2300      	movs	r3, #0
 80018a0:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
}
 80018a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
 80018a8:	f7ff b89a 	b.w	80009e0 <_port_irq_epilogue>
 80018ac:	2320      	movs	r3, #32
 80018ae:	f383 8811 	msr	BASEPRI, r3
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 80018b2:	8cb2      	ldrh	r2, [r6, #36]	; 0x24
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 80018b4:	696b      	ldr	r3, [r5, #20]
 80018b6:	fa5f f882 	uxtb.w	r8, r2
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80018ba:	2b00      	cmp	r3, #0
 80018bc:	d07d      	beq.n	80019ba <VectorD4+0x15a>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80018be:	6a2b      	ldr	r3, [r5, #32]
 80018c0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80018c2:	494a      	ldr	r1, [pc, #296]	; (80019ec <VectorD4+0x18c>)
 80018c4:	4293      	cmp	r3, r2
 80018c6:	d07c      	beq.n	80019c2 <VectorD4+0x162>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 80018c8:	696a      	ldr	r2, [r5, #20]
 80018ca:	4948      	ldr	r1, [pc, #288]	; (80019ec <VectorD4+0x18c>)
 80018cc:	3201      	adds	r2, #1
 80018ce:	616a      	str	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 80018d0:	1c5a      	adds	r2, r3, #1
 80018d2:	622a      	str	r2, [r5, #32]
 80018d4:	f883 8000 	strb.w	r8, [r3]
  if (iqp->q_wrptr >= iqp->q_top) {
 80018d8:	6a2a      	ldr	r2, [r5, #32]
 80018da:	69eb      	ldr	r3, [r5, #28]
 80018dc:	429a      	cmp	r2, r3
 80018de:	d261      	bcs.n	80019a4 <VectorD4+0x144>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80018e0:	4942      	ldr	r1, [pc, #264]	; (80019ec <VectorD4+0x18c>)
 80018e2:	68eb      	ldr	r3, [r5, #12]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 80018e4:	f101 020c 	add.w	r2, r1, #12
 80018e8:	4293      	cmp	r3, r2
 80018ea:	d007      	beq.n	80018fc <VectorD4+0x9c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80018ec:	6818      	ldr	r0, [r3, #0]
 80018ee:	60c8      	str	r0, [r1, #12]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80018f0:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 80018f2:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 80018f4:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80018f6:	6219      	str	r1, [r3, #32]
  (void) chSchReadyI(tp);
 80018f8:	f7ff fb8a 	bl	8001010 <chSchReadyI>
 80018fc:	2300      	movs	r3, #0
 80018fe:	f383 8811 	msr	BASEPRI, r3
 8001902:	e7ba      	b.n	800187a <VectorD4+0x1a>
 8001904:	2320      	movs	r3, #32
 8001906:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800190a:	f44f 7000 	mov.w	r0, #512	; 0x200
 800190e:	f000 fff7 	bl	8002900 <chEvtBroadcastFlagsI.constprop.35>
 8001912:	2300      	movs	r3, #0
 8001914:	f383 8811 	msr	BASEPRI, r3
 8001918:	e7ad      	b.n	8001876 <VectorD4+0x16>
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
    sts |= SD_OVERRUN_ERROR;
 800191a:	f014 0f08 	tst.w	r4, #8
 800191e:	bf0c      	ite	eq
 8001920:	2000      	moveq	r0, #0
 8001922:	2080      	movne	r0, #128	; 0x80
  if (isr & USART_ISR_PE)
 8001924:	07e3      	lsls	r3, r4, #31
    sts |= SD_PARITY_ERROR;
 8001926:	bf48      	it	mi
 8001928:	f040 0020 	orrmi.w	r0, r0, #32
  if (isr & USART_ISR_FE)
 800192c:	07a1      	lsls	r1, r4, #30
    sts |= SD_FRAMING_ERROR;
 800192e:	bf48      	it	mi
 8001930:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
  if (isr & USART_ISR_NE)
 8001934:	0762      	lsls	r2, r4, #29
    sts |= SD_NOISE_ERROR;
 8001936:	bf48      	it	mi
 8001938:	f440 7080 	orrmi.w	r0, r0, #256	; 0x100
 800193c:	2320      	movs	r3, #32
 800193e:	f383 8811 	msr	BASEPRI, r3
 8001942:	f000 ffdd 	bl	8002900 <chEvtBroadcastFlagsI.constprop.35>
 8001946:	2300      	movs	r3, #0
 8001948:	f383 8811 	msr	BASEPRI, r3
 800194c:	e791      	b.n	8001872 <VectorD4+0x12>
 800194e:	2320      	movs	r3, #32
 8001950:	f383 8811 	msr	BASEPRI, r3
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8001954:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8001956:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8001958:	4924      	ldr	r1, [pc, #144]	; (80019ec <VectorD4+0x18c>)
 800195a:	429a      	cmp	r2, r3
 800195c:	d039      	beq.n	80019d2 <VectorD4+0x172>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 800195e:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8001960:	4922      	ldr	r1, [pc, #136]	; (80019ec <VectorD4+0x18c>)
  b = *oqp->q_rdptr++;
 8001962:	1c58      	adds	r0, r3, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8001964:	3201      	adds	r2, #1
 8001966:	63aa      	str	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8001968:	64a8      	str	r0, [r5, #72]	; 0x48
 800196a:	f893 8000 	ldrb.w	r8, [r3]
  if (oqp->q_rdptr >= oqp->q_top) {
 800196e:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8001970:	4298      	cmp	r0, r3
 8001972:	d301      	bcc.n	8001978 <VectorD4+0x118>
    oqp->q_rdptr = oqp->q_buffer;
 8001974:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8001976:	648b      	str	r3, [r1, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001978:	491c      	ldr	r1, [pc, #112]	; (80019ec <VectorD4+0x18c>)
 800197a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800197c:	f101 0230 	add.w	r2, r1, #48	; 0x30
 8001980:	4293      	cmp	r3, r2
 8001982:	d007      	beq.n	8001994 <VectorD4+0x134>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001984:	6818      	ldr	r0, [r3, #0]
 8001986:	6308      	str	r0, [r1, #48]	; 0x30

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001988:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 800198a:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 800198c:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 800198e:	6219      	str	r1, [r3, #32]
  (void) chSchReadyI(tp);
 8001990:	f7ff fb3e 	bl	8001010 <chSchReadyI>
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 8001994:	fa1f f888 	uxth.w	r8, r8
 8001998:	f8a6 8028 	strh.w	r8, [r6, #40]	; 0x28
 800199c:	2300      	movs	r3, #0
 800199e:	f383 8811 	msr	BASEPRI, r3
 80019a2:	e76e      	b.n	8001882 <VectorD4+0x22>
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
    iqp->q_wrptr = iqp->q_buffer;
 80019a4:	698b      	ldr	r3, [r1, #24]
 80019a6:	620b      	str	r3, [r1, #32]
 80019a8:	e79a      	b.n	80018e0 <VectorD4+0x80>
 80019aa:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 80019ac:	2b00      	cmp	r3, #0
 80019ae:	f43f af73 	beq.w	8001898 <VectorD4+0x38>
 80019b2:	2010      	movs	r0, #16
 80019b4:	f000 ffa4 	bl	8002900 <chEvtBroadcastFlagsI.constprop.35>
 80019b8:	e76e      	b.n	8001898 <VectorD4+0x38>
 80019ba:	2004      	movs	r0, #4
 80019bc:	f000 ffa0 	bl	8002900 <chEvtBroadcastFlagsI.constprop.35>
 80019c0:	e77d      	b.n	80018be <VectorD4+0x5e>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80019c2:	694a      	ldr	r2, [r1, #20]
 80019c4:	2a00      	cmp	r2, #0
 80019c6:	f43f af7f 	beq.w	80018c8 <VectorD4+0x68>
 80019ca:	2080      	movs	r0, #128	; 0x80
 80019cc:	f000 ff98 	bl	8002900 <chEvtBroadcastFlagsI.constprop.35>
 80019d0:	e794      	b.n	80018fc <VectorD4+0x9c>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80019d2:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 80019d4:	2a00      	cmp	r2, #0
 80019d6:	d0c2      	beq.n	800195e <VectorD4+0xfe>
 80019d8:	2008      	movs	r0, #8
 80019da:	f000 ff91 	bl	8002900 <chEvtBroadcastFlagsI.constprop.35>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80019de:	f027 03c0 	bic.w	r3, r7, #192	; 0xc0
 80019e2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80019e6:	6033      	str	r3, [r6, #0]
 80019e8:	e7d8      	b.n	800199c <VectorD4+0x13c>
 80019ea:	bf00      	nop
 80019ec:	200010f8 	.word	0x200010f8

080019f0 <VectorC0>:
  i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
}

OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 80019f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t isr = I2CD1.i2c->ISR;
 80019f2:	4b26      	ldr	r3, [pc, #152]	; (8001a8c <VectorC0+0x9c>)
 80019f4:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {

#if STM32_I2C_USE_DMA == TRUE
  /* Clears DMA interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 80019f6:	6ada      	ldr	r2, [r3, #44]	; 0x2c

  OSAL_IRQ_EPILOGUE();
}

OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint32_t isr = I2CD1.i2c->ISR;
 80019f8:	69a1      	ldr	r1, [r4, #24]
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {

#if STM32_I2C_USE_DMA == TRUE
  /* Clears DMA interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 80019fa:	6856      	ldr	r6, [r2, #4]
  dmaStreamDisable(i2cp->dmarx);
 80019fc:	6a98      	ldr	r0, [r3, #40]	; 0x28
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {

#if STM32_I2C_USE_DMA == TRUE
  /* Clears DMA interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 80019fe:	6817      	ldr	r7, [r2, #0]
  uint32_t isr = I2CD1.i2c->ISR;

  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_ERROR_MASK;
 8001a00:	f401 557c 	and.w	r5, r1, #16128	; 0x3f00
 8001a04:	61e5      	str	r5, [r4, #28]
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {

#if STM32_I2C_USE_DMA == TRUE
  /* Clears DMA interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8001a06:	6834      	ldr	r4, [r6, #0]
  dmaStreamDisable(i2cp->dmarx);
 8001a08:	6845      	ldr	r5, [r0, #4]
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {

#if STM32_I2C_USE_DMA == TRUE
  /* Clears DMA interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8001a0a:	f024 040f 	bic.w	r4, r4, #15
 8001a0e:	6034      	str	r4, [r6, #0]
 8001a10:	7c14      	ldrb	r4, [r2, #16]
  dmaStreamDisable(i2cp->dmarx);
 8001a12:	6806      	ldr	r6, [r0, #0]
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {

#if STM32_I2C_USE_DMA == TRUE
  /* Clears DMA interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8001a14:	220e      	movs	r2, #14
 8001a16:	fa02 f404 	lsl.w	r4, r2, r4
 8001a1a:	607c      	str	r4, [r7, #4]
  dmaStreamDisable(i2cp->dmarx);
 8001a1c:	682c      	ldr	r4, [r5, #0]
 8001a1e:	f024 040f 	bic.w	r4, r4, #15
 8001a22:	602c      	str	r4, [r5, #0]
 8001a24:	7c00      	ldrb	r0, [r0, #16]
 8001a26:	4082      	lsls	r2, r0
 8001a28:	6072      	str	r2, [r6, #4]
  /* Disabling RX and TX interrupts.*/
  i2cp->i2c->CR1 &= ~(I2C_CR1_TXIE | I2C_CR1_RXIE);
#endif

  if (isr & I2C_ISR_BERR)
    i2cp->errors |= I2C_BUS_ERROR;
 8001a2a:	689a      	ldr	r2, [r3, #8]
#else
  /* Disabling RX and TX interrupts.*/
  i2cp->i2c->CR1 &= ~(I2C_CR1_TXIE | I2C_CR1_RXIE);
#endif

  if (isr & I2C_ISR_BERR)
 8001a2c:	05ce      	lsls	r6, r1, #23
    i2cp->errors |= I2C_BUS_ERROR;
 8001a2e:	bf44      	itt	mi
 8001a30:	f042 0201 	orrmi.w	r2, r2, #1
 8001a34:	609a      	strmi	r2, [r3, #8]

  if (isr & I2C_ISR_ARLO)
 8001a36:	058d      	lsls	r5, r1, #22
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8001a38:	bf44      	itt	mi
 8001a3a:	f042 0202 	orrmi.w	r2, r2, #2
 8001a3e:	609a      	strmi	r2, [r3, #8]

  if (isr & I2C_ISR_OVR)
 8001a40:	054c      	lsls	r4, r1, #21
 8001a42:	d51b      	bpl.n	8001a7c <VectorC0+0x8c>
    i2cp->errors |= I2C_OVERRUN;
 8001a44:	f042 0208 	orr.w	r2, r2, #8

  if (isr & I2C_ISR_TIMEOUT)
 8001a48:	04c8      	lsls	r0, r1, #19

  if (isr & I2C_ISR_ARLO)
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (isr & I2C_ISR_OVR)
    i2cp->errors |= I2C_OVERRUN;
 8001a4a:	609a      	str	r2, [r3, #8]

  if (isr & I2C_ISR_TIMEOUT)
 8001a4c:	d502      	bpl.n	8001a54 <VectorC0+0x64>
    i2cp->errors |= I2C_TIMEOUT;
 8001a4e:	f042 0220 	orr.w	r2, r2, #32
 8001a52:	609a      	str	r2, [r3, #8]
 8001a54:	2220      	movs	r2, #32
 8001a56:	f382 8811 	msr	BASEPRI, r2
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8001a5a:	69d8      	ldr	r0, [r3, #28]
 8001a5c:	4b0b      	ldr	r3, [pc, #44]	; (8001a8c <VectorC0+0x9c>)
 8001a5e:	b130      	cbz	r0, 8001a6e <VectorC0+0x7e>

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8001a60:	f06f 0201 	mvn.w	r2, #1
 8001a64:	6202      	str	r2, [r0, #32]
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001a66:	2200      	movs	r2, #0
 8001a68:	61da      	str	r2, [r3, #28]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8001a6a:	f7ff fad1 	bl	8001010 <chSchReadyI>
 8001a6e:	2300      	movs	r3, #0
 8001a70:	f383 8811 	msr	BASEPRI, r3
  I2CD1.i2c->ICR = isr & I2C_ERROR_MASK;

  i2c_lld_serve_error_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
}
 8001a74:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_ERROR_MASK;

  i2c_lld_serve_error_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
 8001a78:	f7fe bfb2 	b.w	80009e0 <_port_irq_epilogue>
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (isr & I2C_ISR_OVR)
    i2cp->errors |= I2C_OVERRUN;

  if (isr & I2C_ISR_TIMEOUT)
 8001a7c:	04c9      	lsls	r1, r1, #19
 8001a7e:	d4e6      	bmi.n	8001a4e <VectorC0+0x5e>
    i2cp->errors |= I2C_TIMEOUT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8001a80:	2a00      	cmp	r2, #0
 8001a82:	d1e7      	bne.n	8001a54 <VectorC0+0x64>
  I2CD1.i2c->ICR = isr & I2C_ERROR_MASK;

  i2c_lld_serve_error_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
}
 8001a84:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_ERROR_MASK;

  i2c_lld_serve_error_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
 8001a88:	f7fe bfaa 	b.w	80009e0 <_port_irq_epilogue>
 8001a8c:	20001354 	.word	0x20001354

08001a90 <VectorBC>:
  OSAL_IRQ_EPILOGUE();
}

#elif defined(STM32_I2C1_EVENT_HANDLER) && defined(STM32_I2C1_ERROR_HANDLER)
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
  uint32_t isr = I2CD1.i2c->ISR;
 8001a90:	496c      	ldr	r1, [pc, #432]	; (8001c44 <VectorBC+0x1b4>)
 8001a92:	6b0a      	ldr	r2, [r1, #48]	; 0x30

  OSAL_IRQ_EPILOGUE();
}

#elif defined(STM32_I2C1_EVENT_HANDLER) && defined(STM32_I2C1_ERROR_HANDLER)
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 8001a94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t isr = I2CD1.i2c->ISR;
 8001a96:	6993      	ldr	r3, [r2, #24]

  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;
 8001a98:	f003 00fe 	and.w	r0, r3, #254	; 0xfe
 8001a9c:	61d0      	str	r0, [r2, #28]
 */
static void i2c_lld_serve_interrupt(I2CDriver *i2cp, uint32_t isr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
 8001a9e:	f013 0010 	ands.w	r0, r3, #16
 8001aa2:	d14e      	bne.n	8001b42 <VectorBC+0xb2>
    }
  }
#endif

  /* Partial transfer handling, restarting the transfer and returning.*/
  if ((isr & I2C_ISR_TCR) != 0U) {
 8001aa4:	f013 0480 	ands.w	r4, r3, #128	; 0x80
 8001aa8:	d021      	beq.n	8001aee <VectorBC+0x5e>
    if (i2cp->state == I2C_ACTIVE_TX) {
 8001aaa:	780b      	ldrb	r3, [r1, #0]
 8001aac:	2b03      	cmp	r3, #3
 8001aae:	f000 80af 	beq.w	8001c10 <VectorBC+0x180>
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
 8001ab2:	6a8b      	ldr	r3, [r1, #40]	; 0x28
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001ab4:	6849      	ldr	r1, [r1, #4]
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
 8001ab6:	685b      	ldr	r3, [r3, #4]
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8001ab8:	6889      	ldr	r1, [r1, #8]
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
 8001aba:	685b      	ldr	r3, [r3, #4]
  if (n > 255U) {
 8001abc:	2bff      	cmp	r3, #255	; 0xff
 8001abe:	bf98      	it	ls
 8001ac0:	041c      	lslls	r4, r3, #16
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001ac2:	6853      	ldr	r3, [r2, #4]
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8001ac4:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 8001ac8:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 8001acc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8001ad0:	bf88      	it	hi
 8001ad2:	f04f 7080 	movhi.w	r0, #16777216	; 0x1000000
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8001ad6:	ea43 0301 	orr.w	r3, r3, r1
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
 8001ada:	bf88      	it	hi
 8001adc:	f44f 047f 	movhi.w	r4, #16711680	; 0xff0000
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8001ae0:	4318      	orrs	r0, r3
 8001ae2:	4320      	orrs	r0, r4
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001ae4:	6050      	str	r0, [r2, #4]
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;

  i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
}
 8001ae6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;

  i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
 8001aea:	f7fe bf79 	b.w	80009e0 <_port_irq_epilogue>
    }
    return;
  }

  /* The following condition is true if a transfer phase has been completed.*/
  if ((isr & I2C_ISR_TC) != 0U) {
 8001aee:	065b      	lsls	r3, r3, #25
 8001af0:	d5f9      	bpl.n	8001ae6 <VectorBC+0x56>
    if (i2cp->state == I2C_ACTIVE_TX) {
 8001af2:	780b      	ldrb	r3, [r1, #0]
 8001af4:	2b03      	cmp	r3, #3
 8001af6:	d059      	beq.n	8001bac <VectorBC+0x11c>
    }
    else {
      /* End of the receive phase.*/
#if STM32_I2C_USE_DMA == TRUE
      /* Disabling RX DMA channel.*/
      dmaStreamDisable(i2cp->dmarx);
 8001af8:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8001afa:	685c      	ldr	r4, [r3, #4]
 8001afc:	681d      	ldr	r5, [r3, #0]
 8001afe:	6820      	ldr	r0, [r4, #0]
 8001b00:	f020 000f 	bic.w	r0, r0, #15
 8001b04:	6020      	str	r0, [r4, #0]
 8001b06:	7c18      	ldrb	r0, [r3, #16]
 8001b08:	230e      	movs	r3, #14
 8001b0a:	4083      	lsls	r3, r0
 8001b0c:	606b      	str	r3, [r5, #4]
#endif
    }

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8001b0e:	6853      	ldr	r3, [r2, #4]
 8001b10:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001b14:	6053      	str	r3, [r2, #4]

    /* Make sure no more 'Transfer Complete' interrupts.*/
    dp->CR1 &= ~I2C_CR1_TCIE;
 8001b16:	6813      	ldr	r3, [r2, #0]
 8001b18:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001b1c:	6013      	str	r3, [r2, #0]
 8001b1e:	2320      	movs	r3, #32
 8001b20:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8001b24:	69c8      	ldr	r0, [r1, #28]
 8001b26:	4a47      	ldr	r2, [pc, #284]	; (8001c44 <VectorBC+0x1b4>)
 8001b28:	b120      	cbz	r0, 8001b34 <VectorBC+0xa4>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001b2a:	2300      	movs	r3, #0
    tp->p_u.rdymsg = msg;
 8001b2c:	6203      	str	r3, [r0, #32]
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001b2e:	61d3      	str	r3, [r2, #28]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8001b30:	f7ff fa6e 	bl	8001010 <chSchReadyI>
 8001b34:	2300      	movs	r3, #0
 8001b36:	f383 8811 	msr	BASEPRI, r3
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;

  i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
}
 8001b3a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;

  i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
 8001b3e:	f7fe bf4f 	b.w	80009e0 <_port_irq_epilogue>

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
#if STM32_I2C_USE_DMA == TRUE
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
 8001b42:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    dmaStreamDisable(i2cp->dmarx);
 8001b44:	6a8c      	ldr	r4, [r1, #40]	; 0x28

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
#if STM32_I2C_USE_DMA == TRUE
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
 8001b46:	685d      	ldr	r5, [r3, #4]
    dmaStreamDisable(i2cp->dmarx);
 8001b48:	6866      	ldr	r6, [r4, #4]

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
#if STM32_I2C_USE_DMA == TRUE
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
 8001b4a:	6828      	ldr	r0, [r5, #0]
 8001b4c:	f8d3 e000 	ldr.w	lr, [r3]
    dmaStreamDisable(i2cp->dmarx);
 8001b50:	6827      	ldr	r7, [r4, #0]

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
#if STM32_I2C_USE_DMA == TRUE
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
 8001b52:	f020 000f 	bic.w	r0, r0, #15
 8001b56:	6028      	str	r0, [r5, #0]
 8001b58:	7c18      	ldrb	r0, [r3, #16]
 8001b5a:	230e      	movs	r3, #14
 8001b5c:	fa03 f000 	lsl.w	r0, r3, r0
 8001b60:	f8ce 0004 	str.w	r0, [lr, #4]
    dmaStreamDisable(i2cp->dmarx);
 8001b64:	6835      	ldr	r5, [r6, #0]
#endif

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;
 8001b66:	6888      	ldr	r0, [r1, #8]
  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
#if STM32_I2C_USE_DMA == TRUE
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
    dmaStreamDisable(i2cp->dmarx);
 8001b68:	f025 050f 	bic.w	r5, r5, #15
 8001b6c:	6035      	str	r5, [r6, #0]
 8001b6e:	7c24      	ldrb	r4, [r4, #16]
 8001b70:	40a3      	lsls	r3, r4
 8001b72:	607b      	str	r3, [r7, #4]

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8001b74:	6853      	ldr	r3, [r2, #4]
    dmaStreamDisable(i2cp->dmatx);
    dmaStreamDisable(i2cp->dmarx);
#endif

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;
 8001b76:	f040 0004 	orr.w	r0, r0, #4

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8001b7a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    dmaStreamDisable(i2cp->dmatx);
    dmaStreamDisable(i2cp->dmarx);
#endif

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;
 8001b7e:	6088      	str	r0, [r1, #8]

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8001b80:	6053      	str	r3, [r2, #4]

    /* Make sure no more interrupts.*/
    dp->CR1 &= ~(I2C_CR1_TCIE | I2C_CR1_TXIE | I2C_CR1_RXIE);
 8001b82:	6813      	ldr	r3, [r2, #0]
 8001b84:	f023 0346 	bic.w	r3, r3, #70	; 0x46
 8001b88:	6013      	str	r3, [r2, #0]
 8001b8a:	2320      	movs	r3, #32
 8001b8c:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8001b90:	69c8      	ldr	r0, [r1, #28]
 8001b92:	2800      	cmp	r0, #0
 8001b94:	d0ce      	beq.n	8001b34 <VectorBC+0xa4>

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8001b96:	f06f 0301 	mvn.w	r3, #1
 8001b9a:	6203      	str	r3, [r0, #32]
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001b9c:	2300      	movs	r3, #0
 8001b9e:	61cb      	str	r3, [r1, #28]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8001ba0:	f7ff fa36 	bl	8001010 <chSchReadyI>
 8001ba4:	2300      	movs	r3, #0
 8001ba6:	f383 8811 	msr	BASEPRI, r3
 8001baa:	e7c6      	b.n	8001b3a <VectorBC+0xaa>
    if (i2cp->state == I2C_ACTIVE_TX) {
      /* End of the transmit phase.*/

#if STM32_I2C_USE_DMA == TRUE
      /* Disabling TX DMA channel.*/
      dmaStreamDisable(i2cp->dmatx);
 8001bac:	6acb      	ldr	r3, [r1, #44]	; 0x2c
#endif

      /* Starting receive phase if necessary.*/
      if (i2c_lld_get_rxbytes(i2cp) > 0U) {
 8001bae:	6a88      	ldr	r0, [r1, #40]	; 0x28
    if (i2cp->state == I2C_ACTIVE_TX) {
      /* End of the transmit phase.*/

#if STM32_I2C_USE_DMA == TRUE
      /* Disabling TX DMA channel.*/
      dmaStreamDisable(i2cp->dmatx);
 8001bb0:	685e      	ldr	r6, [r3, #4]
#endif

      /* Starting receive phase if necessary.*/
      if (i2c_lld_get_rxbytes(i2cp) > 0U) {
 8001bb2:	6845      	ldr	r5, [r0, #4]
    if (i2cp->state == I2C_ACTIVE_TX) {
      /* End of the transmit phase.*/

#if STM32_I2C_USE_DMA == TRUE
      /* Disabling TX DMA channel.*/
      dmaStreamDisable(i2cp->dmatx);
 8001bb4:	6830      	ldr	r0, [r6, #0]
 8001bb6:	681f      	ldr	r7, [r3, #0]
 8001bb8:	f020 000f 	bic.w	r0, r0, #15
 8001bbc:	6030      	str	r0, [r6, #0]
 8001bbe:	7c18      	ldrb	r0, [r3, #16]
 8001bc0:	230e      	movs	r3, #14
 8001bc2:	4083      	lsls	r3, r0
 8001bc4:	607b      	str	r3, [r7, #4]
#endif

      /* Starting receive phase if necessary.*/
      if (i2c_lld_get_rxbytes(i2cp) > 0U) {
 8001bc6:	686b      	ldr	r3, [r5, #4]
 8001bc8:	2b00      	cmp	r3, #0
 8001bca:	d0a0      	beq.n	8001b0e <VectorBC+0x7e>
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
 8001bcc:	686b      	ldr	r3, [r5, #4]
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001bce:	684e      	ldr	r6, [r1, #4]
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
 8001bd0:	2bff      	cmp	r3, #255	; 0xff
 8001bd2:	bf98      	it	ls
 8001bd4:	0418      	lslls	r0, r3, #16
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001bd6:	6853      	ldr	r3, [r2, #4]
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8001bd8:	68b6      	ldr	r6, [r6, #8]
 8001bda:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 8001bde:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
 8001be2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001be6:	ea43 0306 	orr.w	r3, r3, r6

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8001bea:	bf84      	itt	hi
 8001bec:	f04f 7480 	movhi.w	r4, #16777216	; 0x1000000
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
 8001bf0:	f44f 007f 	movhi.w	r0, #16711680	; 0xff0000
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8001bf4:	431c      	orrs	r4, r3
 8001bf6:	4304      	orrs	r4, r0
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001bf8:	6054      	str	r4, [r2, #4]
        /* Setting up the peripheral.*/
        i2c_lld_setup_rx_transfer(i2cp);

#if STM32_I2C_USE_DMA == TRUE
        /* Enabling RX DMA.*/
        dmaStreamEnable(i2cp->dmarx);
 8001bfa:	682b      	ldr	r3, [r5, #0]
 8001bfc:	f043 0301 	orr.w	r3, r3, #1
 8001c00:	602b      	str	r3, [r5, #0]
        /* RX interrupt enabled.*/
        dp->CR1 |= I2C_CR1_RXIE;
#endif

        /* Starts the read operation.*/
        dp->CR2 |= I2C_CR2_START;
 8001c02:	6853      	ldr	r3, [r2, #4]

        /* State change.*/
        i2cp->state = I2C_ACTIVE_RX;
 8001c04:	2004      	movs	r0, #4
        /* RX interrupt enabled.*/
        dp->CR1 |= I2C_CR1_RXIE;
#endif

        /* Starts the read operation.*/
        dp->CR2 |= I2C_CR2_START;
 8001c06:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001c0a:	6053      	str	r3, [r2, #4]

        /* State change.*/
        i2cp->state = I2C_ACTIVE_RX;
 8001c0c:	7008      	strb	r0, [r1, #0]
 8001c0e:	e76a      	b.n	8001ae6 <VectorBC+0x56>
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 8001c10:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001c12:	684c      	ldr	r4, [r1, #4]
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 8001c14:	685b      	ldr	r3, [r3, #4]
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            (n << 16U) | reload;
 8001c16:	68a4      	ldr	r4, [r4, #8]
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 8001c18:	685b      	ldr	r3, [r3, #4]
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001c1a:	6851      	ldr	r1, [r2, #4]
            (n << 16U) | reload;
 8001c1c:	f021 71ff 	bic.w	r1, r1, #33423360	; 0x1fe0000
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
 8001c20:	2bff      	cmp	r3, #255	; 0xff
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            (n << 16U) | reload;
 8001c22:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8001c26:	ea41 0104 	orr.w	r1, r1, r4

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8001c2a:	bf8a      	itet	hi
 8001c2c:	f04f 7080 	movhi.w	r0, #16777216	; 0x1000000
 8001c30:	041b      	lslls	r3, r3, #16
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
 8001c32:	f44f 037f 	movhi.w	r3, #16711680	; 0xff0000
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            (n << 16U) | reload;
 8001c36:	4308      	orrs	r0, r1
 8001c38:	4318      	orrs	r0, r3
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001c3a:	6050      	str	r0, [r2, #4]
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;

  i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
}
 8001c3c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;

  i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
 8001c40:	f7fe bece 	b.w	80009e0 <_port_irq_epilogue>
 8001c44:	20001354 	.word	0x20001354
	...

08001c50 <setState>:
}
/**********************************************/


void setState(int role, int state){
	currentState[role]=state;
 8001c50:	4b0f      	ldr	r3, [pc, #60]	; (8001c90 <setState+0x40>)
 8001c52:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

	switch(role){
 8001c56:	b150      	cbz	r0, 8001c6e <setState+0x1e>
 8001c58:	2801      	cmp	r0, #1
 8001c5a:	d106      	bne.n	8001c6a <setState+0x1a>
				/*case DisabledRoll:
				break;*/
			}
		break;
		case AltAssistance:
			switch(state){
 8001c5c:	2905      	cmp	r1, #5
 8001c5e:	d105      	bne.n	8001c6c <setState+0x1c>
}
/**********************************************/


void setState(int role, int state){
	currentState[role]=state;
 8001c60:	2202      	movs	r2, #2
 8001c62:	601a      	str	r2, [r3, #0]
 8001c64:	2201      	movs	r2, #1
 8001c66:	60da      	str	r2, [r3, #12]
 8001c68:	4770      	bx	lr
 8001c6a:	4770      	bx	lr
 8001c6c:	4770      	bx	lr

	switch(role){
		case RollAssistance:
			switch(state){
 8001c6e:	2903      	cmp	r1, #3
 8001c70:	d8fc      	bhi.n	8001c6c <setState+0x1c>
 8001c72:	a201      	add	r2, pc, #4	; (adr r2, 8001c78 <setState+0x28>)
 8001c74:	f852 f021 	ldr.w	pc, [r2, r1, lsl #2]
 8001c78:	08001c89 	.word	0x08001c89
 8001c7c:	08001c89 	.word	0x08001c89
 8001c80:	08001c65 	.word	0x08001c65
 8001c84:	08001c65 	.word	0x08001c65
}
/**********************************************/


void setState(int role, int state){
	currentState[role]=state;
 8001c88:	2200      	movs	r2, #0
 8001c8a:	60da      	str	r2, [r3, #12]
 8001c8c:	4770      	bx	lr
 8001c8e:	bf00      	nop
 8001c90:	20000e78 	.word	0x20000e78
	...

08001ca0 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001ca0:	4924      	ldr	r1, [pc, #144]	; (8001d34 <__early_init+0x94>)
 8001ca2:	680b      	ldr	r3, [r1, #0]
 8001ca4:	f043 0301 	orr.w	r3, r3, #1
 8001ca8:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001caa:	680a      	ldr	r2, [r1, #0]
 8001cac:	4b21      	ldr	r3, [pc, #132]	; (8001d34 <__early_init+0x94>)
 8001cae:	0790      	lsls	r0, r2, #30
 8001cb0:	d5fb      	bpl.n	8001caa <__early_init+0xa>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001cb2:	685a      	ldr	r2, [r3, #4]
 8001cb4:	f022 0203 	bic.w	r2, r2, #3
 8001cb8:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001cba:	685a      	ldr	r2, [r3, #4]
 8001cbc:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001cbe:	4619      	mov	r1, r3
 8001cc0:	684b      	ldr	r3, [r1, #4]
 8001cc2:	4a1c      	ldr	r2, [pc, #112]	; (8001d34 <__early_init+0x94>)
 8001cc4:	f013 030c 	ands.w	r3, r3, #12
 8001cc8:	d1fa      	bne.n	8001cc0 <__early_init+0x20>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001cca:	6811      	ldr	r1, [r2, #0]
 8001ccc:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 8001cd0:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001cd2:	6053      	str	r3, [r2, #4]

#if STM32_HSE_ENABLED
  /* HSE activation.*/
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 8001cd4:	6813      	ldr	r3, [r2, #0]
 8001cd6:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
 8001cda:	6013      	str	r3, [r2, #0]
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 8001cdc:	6811      	ldr	r1, [r2, #0]
 8001cde:	4b15      	ldr	r3, [pc, #84]	; (8001d34 <__early_init+0x94>)
 8001ce0:	0389      	lsls	r1, r1, #14
 8001ce2:	d5fb      	bpl.n	8001cdc <__early_init+0x3c>
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001ce4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001ce6:	f042 0201 	orr.w	r2, r2, #1
 8001cea:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001cec:	461a      	mov	r2, r3
 8001cee:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8001cf0:	4b10      	ldr	r3, [pc, #64]	; (8001d34 <__early_init+0x94>)
 8001cf2:	0788      	lsls	r0, r1, #30
 8001cf4:	d5fb      	bpl.n	8001cee <__early_init+0x4e>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
 8001cf6:	4a10      	ldr	r2, [pc, #64]	; (8001d38 <__early_init+0x98>)
 8001cf8:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8001cfa:	f44f 5104 	mov.w	r1, #8448	; 0x2100
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8001cfe:	2230      	movs	r2, #48	; 0x30

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8001d00:	62d9      	str	r1, [r3, #44]	; 0x2c
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8001d02:	631a      	str	r2, [r3, #48]	; 0x30
               STM32_USART2SW  | STM32_I2C2SW    | STM32_I2C1SW   |
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001d04:	681a      	ldr	r2, [r3, #0]
 8001d06:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001d0a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001d0c:	6819      	ldr	r1, [r3, #0]
 8001d0e:	4a09      	ldr	r2, [pc, #36]	; (8001d34 <__early_init+0x94>)
 8001d10:	0189      	lsls	r1, r1, #6
 8001d12:	d5fb      	bpl.n	8001d0c <__early_init+0x6c>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001d14:	4b09      	ldr	r3, [pc, #36]	; (8001d3c <__early_init+0x9c>)
 8001d16:	2112      	movs	r1, #18
 8001d18:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001d1a:	6853      	ldr	r3, [r2, #4]
 8001d1c:	f043 0302 	orr.w	r3, r3, #2
 8001d20:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001d22:	6853      	ldr	r3, [r2, #4]
 8001d24:	4903      	ldr	r1, [pc, #12]	; (8001d34 <__early_init+0x94>)
 8001d26:	f003 030c 	and.w	r3, r3, #12
 8001d2a:	2b08      	cmp	r3, #8
 8001d2c:	d1f9      	bne.n	8001d22 <__early_init+0x82>
    ;                                       /* Waits selection complete.    */
#endif

  /* After PLL activation because the special requirements for TIM1 and
     TIM8 bits.*/
  RCC->CFGR3 |= STM32_TIM8SW | STM32_TIM1SW;
 8001d2e:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8001d30:	630b      	str	r3, [r1, #48]	; 0x30
 8001d32:	4770      	bx	lr
 8001d34:	40021000 	.word	0x40021000
 8001d38:	001d2400 	.word	0x001d2400
 8001d3c:	40022000 	.word	0x40022000

08001d40 <ModeTask>:
		chThdSleepMilliseconds(100);
	}
}

static THD_WORKING_AREA(waModeTask, 128);
static THD_FUNCTION(ModeTask, arg) {
 8001d40:	b508      	push	{r3, lr}
			break;

			case AutoNavigation:
			break;
		}
		chThdSleepMilliseconds(100);
 8001d42:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001d46:	f7ff f953 	bl	8000ff0 <chThdSleep>
 8001d4a:	e7fa      	b.n	8001d42 <ModeTask+0x2>
 8001d4c:	0000      	movs	r0, r0
	...

08001d50 <RollAssisTask>:
//				chThdSleepMilliseconds(100);
//	}
}

static THD_WORKING_AREA(waRollAssisTask, 128);
static THD_FUNCTION(RollAssisTask, arg) {
 8001d50:	b580      	push	{r7, lr}
 8001d52:	4e56      	ldr	r6, [pc, #344]	; (8001eac <RollAssisTask+0x15c>)
 8001d54:	4c56      	ldr	r4, [pc, #344]	; (8001eb0 <RollAssisTask+0x160>)
 8001d56:	4f57      	ldr	r7, [pc, #348]	; (8001eb4 <RollAssisTask+0x164>)
 8001d58:	b082      	sub	sp, #8
					setState(RollAssistance, EnabledRollBlocking);
				}
			break;

			case EnabledCompensating:
				if((ABS((int8_t)gyroData[0])<1.0f)||(ABS((int8_t)gyroData[1])<1.0f)){		//roll ~= 0
 8001d5a:	46b0      	mov	r8, r6
	(void)arg;
	//some variables
	int altitudeModeChanged=0;
	int rollInput;
	while(TRUE){
		rollInput=palReadPad(GPIOA, GPIOA_BUTTON);
 8001d5c:	f04f 4590 	mov.w	r5, #1207959552	; 0x48000000
 8001d60:	692b      	ldr	r3, [r5, #16]
		switch(currentState[RollAssistance]){
 8001d62:	6822      	ldr	r2, [r4, #0]
	(void)arg;
	//some variables
	int altitudeModeChanged=0;
	int rollInput;
	while(TRUE){
		rollInput=palReadPad(GPIOA, GPIOA_BUTTON);
 8001d64:	f003 0301 	and.w	r3, r3, #1
		switch(currentState[RollAssistance]){
 8001d68:	2a04      	cmp	r2, #4
 8001d6a:	d80e      	bhi.n	8001d8a <RollAssisTask+0x3a>
 8001d6c:	e8df f002 	tbb	[pc, r2]
 8001d70:	122c745a 	.word	0x122c745a
 8001d74:	03          	.byte	0x03
 8001d75:	00          	.byte	0x00
		break;
	}
}

void updateTreshold(int altitudeModeChanged){
	treshold=altitudeModeChanged;
 8001d76:	2302      	movs	r3, #2
				}
			break;

			case EnabledTresholdUpdate:
				updateTreshold(2.0f);
				chThdSleepMilliseconds(100);
 8001d78:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
		break;
	}
}

void updateTreshold(int altitudeModeChanged){
	treshold=altitudeModeChanged;
 8001d7c:	703b      	strb	r3, [r7, #0]
				}
			break;

			case EnabledTresholdUpdate:
				updateTreshold(2.0f);
				chThdSleepMilliseconds(100);
 8001d7e:	f7ff f937 	bl	8000ff0 <chThdSleep>
				setState(RollAssistance, EnabledMonitoring);
 8001d82:	2100      	movs	r1, #0
 8001d84:	4608      	mov	r0, r1
 8001d86:	f7ff ff63 	bl	8001c50 <setState>
						// ENABLE / DISABLE
						setState(RollAssistance, EnabledRoll);
					}
			break;*/
		}
		chThdSleepMilliseconds(100);
 8001d8a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001d8e:	f7ff f92f 	bl	8000ff0 <chThdSleep>
 8001d92:	e7e5      	b.n	8001d60 <RollAssisTask+0x10>
					setState(RollAssistance, EnabledRolling);
				}
			break;

			case EnabledRollBlocking:
				if(((int8_t)gyroData[0] < -3.0f)||(rollInput==0)){				//nosedive == true || roll_input == false
 8001d94:	edd6 7a00 	vldr	s15, [r6]
 8001d98:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001d9c:	eeb8 7a08 	vmov.f32	s14, #136	; 0xc0400000 -3.0
 8001da0:	edcd 7a01 	vstr	s15, [sp, #4]
 8001da4:	f99d 2004 	ldrsb.w	r2, [sp, #4]
 8001da8:	ee07 2a90 	vmov	s15, r2
 8001dac:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001db0:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001db4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001db8:	d401      	bmi.n	8001dbe <RollAssisTask+0x6e>
 8001dba:	2b00      	cmp	r3, #0
 8001dbc:	d1e5      	bne.n	8001d8a <RollAssisTask+0x3a>
				}*/
			break;

			case EnabledRolling:
				if(rollInput==0){ 				//nosedive == true || roll_input == false
					setState(RollAssistance, EnabledCompensating);
 8001dbe:	2102      	movs	r1, #2
 8001dc0:	2000      	movs	r0, #0
 8001dc2:	f7ff ff45 	bl	8001c50 <setState>
 8001dc6:	e7e0      	b.n	8001d8a <RollAssisTask+0x3a>
					setState(RollAssistance, EnabledRollBlocking);
				}
			break;

			case EnabledCompensating:
				if((ABS((int8_t)gyroData[0])<1.0f)||(ABS((int8_t)gyroData[1])<1.0f)){		//roll ~= 0
 8001dc8:	edd6 7a00 	vldr	s15, [r6]
 8001dcc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001dd0:	edcd 7a01 	vstr	s15, [sp, #4]
 8001dd4:	f99d 2004 	ldrsb.w	r2, [sp, #4]
 8001dd8:	2a00      	cmp	r2, #0
 8001dda:	dbd2      	blt.n	8001d82 <RollAssisTask+0x32>
 8001ddc:	ee07 2a90 	vmov	s15, r2
 8001de0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001de4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8001de8:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001dec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001df0:	d4c7      	bmi.n	8001d82 <RollAssisTask+0x32>
 8001df2:	edd8 7a01 	vldr	s15, [r8, #4]
 8001df6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001dfa:	edcd 7a01 	vstr	s15, [sp, #4]
 8001dfe:	f99d 2004 	ldrsb.w	r2, [sp, #4]
 8001e02:	2a00      	cmp	r2, #0
 8001e04:	dbbd      	blt.n	8001d82 <RollAssisTask+0x32>
 8001e06:	ee07 2a90 	vmov	s15, r2
 8001e0a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001e0e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001e12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001e16:	d4b4      	bmi.n	8001d82 <RollAssisTask+0x32>
					setState(RollAssistance, EnabledMonitoring);
				}
				else if((currentState[AltAssistance]==EnabledStallRecovery)&&(rollInput==1)){ 			//nosedive == false || roll_input == true
 8001e18:	6862      	ldr	r2, [r4, #4]
 8001e1a:	2a05      	cmp	r2, #5
 8001e1c:	d1b5      	bne.n	8001d8a <RollAssisTask+0x3a>
 8001e1e:	2b00      	cmp	r3, #0
 8001e20:	d0b3      	beq.n	8001d8a <RollAssisTask+0x3a>
 8001e22:	e014      	b.n	8001e4e <RollAssisTask+0xfe>
				chThdSleepMilliseconds(100);
				setState(RollAssistance, EnabledMonitoring);
			break;*/

			case EnabledMonitoring:
				if((ABS((int8_t)gyroData[0])>1.0f)||(ABS((int8_t)gyroData[1])>1.0f)){		//roll != 0
 8001e24:	edd6 7a00 	vldr	s15, [r6]
 8001e28:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001e2c:	edcd 7a01 	vstr	s15, [sp, #4]
 8001e30:	f99d 3004 	ldrsb.w	r3, [sp, #4]
 8001e34:	2b00      	cmp	r3, #0
 8001e36:	db0a      	blt.n	8001e4e <RollAssisTask+0xfe>
 8001e38:	ee07 3a90 	vmov	s15, r3
 8001e3c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001e40:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8001e44:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001e48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001e4c:	dd19      	ble.n	8001e82 <RollAssisTask+0x132>
					setState(RollAssistance, EnabledRolling);
 8001e4e:	2101      	movs	r1, #1
 8001e50:	2000      	movs	r0, #0
 8001e52:	f7ff fefd 	bl	8001c50 <setState>
 8001e56:	e798      	b.n	8001d8a <RollAssisTask+0x3a>
					setState(RollAssistance, EnabledCompensating);
				}*/
			break;

			case EnabledRolling:
				if(rollInput==0){ 				//nosedive == true || roll_input == false
 8001e58:	2b00      	cmp	r3, #0
 8001e5a:	d0b0      	beq.n	8001dbe <RollAssisTask+0x6e>
					setState(RollAssistance, EnabledCompensating);
				}
				else if(ABS((int8_t)gyroData[1])>treshold){					//roll > treshold (2.0f initial)
 8001e5c:	edd6 7a01 	vldr	s15, [r6, #4]
 8001e60:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001e64:	edcd 7a01 	vstr	s15, [sp, #4]
 8001e68:	f99d 3004 	ldrsb.w	r3, [sp, #4]
 8001e6c:	2b00      	cmp	r3, #0
 8001e6e:	db03      	blt.n	8001e78 <RollAssisTask+0x128>
 8001e70:	f997 2000 	ldrsb.w	r2, [r7]
 8001e74:	429a      	cmp	r2, r3
 8001e76:	da88      	bge.n	8001d8a <RollAssisTask+0x3a>
					setState(RollAssistance, EnabledRollBlocking);
 8001e78:	2103      	movs	r1, #3
 8001e7a:	2000      	movs	r0, #0
 8001e7c:	f7ff fee8 	bl	8001c50 <setState>
 8001e80:	e783      	b.n	8001d8a <RollAssisTask+0x3a>
				chThdSleepMilliseconds(100);
				setState(RollAssistance, EnabledMonitoring);
			break;*/

			case EnabledMonitoring:
				if((ABS((int8_t)gyroData[0])>1.0f)||(ABS((int8_t)gyroData[1])>1.0f)){		//roll != 0
 8001e82:	edd8 7a01 	vldr	s15, [r8, #4]
 8001e86:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001e8a:	edcd 7a01 	vstr	s15, [sp, #4]
 8001e8e:	f99d 3004 	ldrsb.w	r3, [sp, #4]
 8001e92:	2b00      	cmp	r3, #0
 8001e94:	dbdb      	blt.n	8001e4e <RollAssisTask+0xfe>
 8001e96:	ee07 3a90 	vmov	s15, r3
 8001e9a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001e9e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001ea2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001ea6:	dcd2      	bgt.n	8001e4e <RollAssisTask+0xfe>
 8001ea8:	e76f      	b.n	8001d8a <RollAssisTask+0x3a>
 8001eaa:	bf00      	nop
 8001eac:	200009f0 	.word	0x200009f0
 8001eb0:	20000e78 	.word	0x20000e78
 8001eb4:	20000800 	.word	0x20000800
	...

08001ec0 <AltAssisTask>:
	(void)arg;

}

static THD_WORKING_AREA(waAltAssisTask, 128);
static THD_FUNCTION(AltAssisTask, arg) {
 8001ec0:	b500      	push	{lr}
 8001ec2:	4c33      	ldr	r4, [pc, #204]	; (8001f90 <AltAssisTask+0xd0>)
 8001ec4:	4d33      	ldr	r5, [pc, #204]	; (8001f94 <AltAssisTask+0xd4>)
 8001ec6:	b083      	sub	sp, #12
				}
				//Transition from here to emergency state if the timeout is reached
			break;

			case EnabledEmergencyManual:
				if((int8_t)gyroData[0] > 1.0f){		//pitch>0
 8001ec8:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
	int throttle=1;
	int altitudeVal=100;
	int pitchInput=1;

	while(TRUE){
		switch(currentState[AltAssistance]){
 8001ecc:	6863      	ldr	r3, [r4, #4]
 8001ece:	2b06      	cmp	r3, #6
 8001ed0:	d81a      	bhi.n	8001f08 <AltAssisTask+0x48>
 8001ed2:	e8df f003 	tbb	[pc, r3]
 8001ed6:	3d15      	.short	0x3d15
 8001ed8:	041e2332 	.word	0x041e2332
 8001edc:	04          	.byte	0x04
 8001edd:	00          	.byte	0x00
				}
				//Transition from here to emergency state if the timeout is reached
			break;

			case EnabledEmergencyManual:
				if((int8_t)gyroData[0] > 1.0f){		//pitch>0
 8001ede:	edd5 7a00 	vldr	s15, [r5]
 8001ee2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001ee6:	edcd 7a01 	vstr	s15, [sp, #4]
 8001eea:	f99d 3004 	ldrsb.w	r3, [sp, #4]
 8001eee:	ee07 3a90 	vmov	s15, r3
 8001ef2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001ef6:	eef4 7ac8 	vcmpe.f32	s15, s16
 8001efa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001efe:	dd03      	ble.n	8001f08 <AltAssisTask+0x48>
				}
			break;

			case EnabledVerticalClimbing:
				if((int8_t)gyroData[0] < verticalAngle){		//pitch<Vertical_Angle
					setState(AltAssistance, EnabledFlight);
 8001f00:	2101      	movs	r1, #1
 8001f02:	4608      	mov	r0, r1
 8001f04:	f7ff fea4 	bl	8001c50 <setState>
			break;

			/*case DisabledAlt:
			break;*/
		}
		chThdSleepMilliseconds(100);
 8001f08:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001f0c:	f7ff f870 	bl	8000ff0 <chThdSleep>
 8001f10:	e7dc      	b.n	8001ecc <AltAssisTask+0xc>
				}
			break;

			case EnabledAltBlocking:
				if((pitchInput>0)||((int8_t)gyroData[0] > minLandingPitch)){ //pitch_input>0 || pitch>MIN_LANDING_PITCH
					setState(AltAssistance, EnabledLanding);
 8001f12:	2103      	movs	r1, #3
 8001f14:	2001      	movs	r0, #1
 8001f16:	f7ff fe9b 	bl	8001c50 <setState>
 8001f1a:	e7f5      	b.n	8001f08 <AltAssisTask+0x48>
					setState(AltAssistance, EnabledFlight);
				}
			break;

			case EnabledLanding:
				if((int8_t)gyroData[0] < minLandingPitch){		//pitch<MIN_LANDING_PITCH
 8001f1c:	edd5 7a00 	vldr	s15, [r5]
 8001f20:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001f24:	edcd 7a01 	vstr	s15, [sp, #4]
 8001f28:	f99d 3004 	ldrsb.w	r3, [sp, #4]
 8001f2c:	3306      	adds	r3, #6
 8001f2e:	dae7      	bge.n	8001f00 <AltAssisTask+0x40>
					setState(AltAssistance, EnabledAltBlocking);
 8001f30:	2104      	movs	r1, #4
 8001f32:	2001      	movs	r0, #1
 8001f34:	f7ff fe8c 	bl	8001c50 <setState>
 8001f38:	e7e6      	b.n	8001f08 <AltAssisTask+0x48>
					setState(AltAssistance, EnabledStallRecovery);
				}
			break;

			case EnabledVerticalClimbing:
				if((int8_t)gyroData[0] < verticalAngle){		//pitch<Vertical_Angle
 8001f3a:	edd5 7a00 	vldr	s15, [r5]
 8001f3e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001f42:	edcd 7a01 	vstr	s15, [sp, #4]
 8001f46:	f99d 3004 	ldrsb.w	r3, [sp, #4]
 8001f4a:	2b04      	cmp	r3, #4
 8001f4c:	dcdc      	bgt.n	8001f08 <AltAssisTask+0x48>
 8001f4e:	e7d7      	b.n	8001f00 <AltAssisTask+0x40>

			case EnabledFlight:
				if(altitudeVal < landingAltitude){					//altitude<LANDING_ALTITUDE
					setState(AltAssistance, EnabledLanding);
				}
				else if((int8_t)gyroData[0] > verticalAngle){		//pitch>Vertical_Angle
 8001f50:	edd5 7a00 	vldr	s15, [r5]
 8001f54:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001f58:	edcd 7a01 	vstr	s15, [sp, #4]
 8001f5c:	f99d 3004 	ldrsb.w	r3, [sp, #4]
 8001f60:	2b05      	cmp	r3, #5
 8001f62:	dc0f      	bgt.n	8001f84 <AltAssisTask+0xc4>
					setState(AltAssistance, EnabledVerticalClimbing);
				}
				else if(((int8_t)gyroData[0] < -3.0f)){				//nose dive >0
 8001f64:	ee07 3a90 	vmov	s15, r3
 8001f68:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001f6c:	eeb8 7a08 	vmov.f32	s14, #136	; 0xc0400000 -3.0
 8001f70:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001f74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001f78:	d5c6      	bpl.n	8001f08 <AltAssisTask+0x48>
					setState(AltAssistance, EnabledStallRecovery);
 8001f7a:	2105      	movs	r1, #5
 8001f7c:	2001      	movs	r0, #1
 8001f7e:	f7ff fe67 	bl	8001c50 <setState>
 8001f82:	e7c1      	b.n	8001f08 <AltAssisTask+0x48>
			case EnabledFlight:
				if(altitudeVal < landingAltitude){					//altitude<LANDING_ALTITUDE
					setState(AltAssistance, EnabledLanding);
				}
				else if((int8_t)gyroData[0] > verticalAngle){		//pitch>Vertical_Angle
					setState(AltAssistance, EnabledVerticalClimbing);
 8001f84:	2102      	movs	r1, #2
 8001f86:	2001      	movs	r0, #1
 8001f88:	f7ff fe62 	bl	8001c50 <setState>
 8001f8c:	e7bc      	b.n	8001f08 <AltAssisTask+0x48>
 8001f8e:	bf00      	nop
 8001f90:	20000e78 	.word	0x20000e78
 8001f94:	200009f0 	.word	0x200009f0
	...

08001fa0 <GyrosTask>:
void updateTreshold(int altitudeModeChanged){
	treshold=altitudeModeChanged;
}
/**********************TASKS**********************/
static THD_WORKING_AREA(waGyrosTask, 128);
static THD_FUNCTION(GyrosTask, arg) {
 8001fa0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001fa4:	4e32      	ldr	r6, [pc, #200]	; (8002070 <GyrosTask+0xd0>)
 8001fa6:	b086      	sub	sp, #24
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8001fa8:	46b0      	mov	r8, r6
    writeByteI2C(0x19, 0x20, 0x97);
}

static uint8_t readGyro(float* data){
    // setting MSB makes it increment the address for a multiple byte read
    uint8_t start_reg = 0x27 | 0x80;
 8001faa:	27a7      	movs	r7, #167	; 0xa7
 8001fac:	2400      	movs	r4, #0
 8001fae:	f88d 700f 	strb.w	r7, [sp, #15]
 8001fb2:	2520      	movs	r5, #32
 8001fb4:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 8001fb8:	f000 fbf2 	bl	80027a0 <chMtxLockS.constprop.38>
 8001fbc:	f384 8811 	msr	BASEPRI, r4
 8001fc0:	f385 8811 	msr	BASEPRI, r5
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8001fc4:	2307      	movs	r3, #7

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 8001fc6:	2503      	movs	r5, #3
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8001fc8:	9300      	str	r3, [sp, #0]
 8001fca:	f10d 010f 	add.w	r1, sp, #15
 8001fce:	ab04      	add	r3, sp, #16
 8001fd0:	2201      	movs	r2, #1
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8001fd2:	60b4      	str	r4, [r6, #8]
  i2cp->state = I2C_ACTIVE_TX;
 8001fd4:	7035      	strb	r5, [r6, #0]
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8001fd6:	2019      	movs	r0, #25
 8001fd8:	f000 fd0a 	bl	80029f0 <i2c_lld_master_transmit_timeout.constprop.20>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 8001fdc:	3001      	adds	r0, #1
    i2cp->state = I2C_LOCKED;
 8001fde:	bf0c      	ite	eq
 8001fe0:	2305      	moveq	r3, #5
  }
  else {
    i2cp->state = I2C_READY;
 8001fe2:	2302      	movne	r3, #2
 8001fe4:	f888 3000 	strb.w	r3, [r8]
 8001fe8:	f384 8811 	msr	BASEPRI, r4
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8001fec:	f000 fc48 	bl	8002880 <chMtxUnlock.constprop.36>
    uint8_t out[7];
    i2cAcquireBus(&I2CD1);
    msg_t f = i2cMasterTransmitTimeout(&I2CD1, 0x19, &start_reg, 1, out, 7, TIME_INFINITE);
    (void)f;
    i2cReleaseBus(&I2CD1);
    if (out[0] & 0x8) {
 8001ff0:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8001ff4:	071b      	lsls	r3, r3, #28
 8001ff6:	d5da      	bpl.n	8001fae <GyrosTask+0xe>
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
 8001ff8:	f89d 6014 	ldrb.w	r6, [sp, #20]
 8001ffc:	f89d 1013 	ldrb.w	r1, [sp, #19]
        int16_t val_z = (out[6] << 8) | out[5];
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
 8002000:	f89d 5012 	ldrb.w	r5, [sp, #18]
 8002004:	f89d 2011 	ldrb.w	r2, [sp, #17]
    (void)f;
    i2cReleaseBus(&I2CD1);
    if (out[0] & 0x8) {
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
        int16_t val_z = (out[6] << 8) | out[5];
 8002008:	f89d 4016 	ldrb.w	r4, [sp, #22]
 800200c:	f89d 3015 	ldrb.w	r3, [sp, #21]
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
 8002010:	ed9f 5a18 	vldr	s10, [pc, #96]	; 8002074 <GyrosTask+0xd4>
 8002014:	eddf 5a18 	vldr	s11, [pc, #96]	; 8002078 <GyrosTask+0xd8>
 8002018:	4818      	ldr	r0, [pc, #96]	; (800207c <GyrosTask+0xdc>)
    msg_t f = i2cMasterTransmitTimeout(&I2CD1, 0x19, &start_reg, 1, out, 7, TIME_INFINITE);
    (void)f;
    i2cReleaseBus(&I2CD1);
    if (out[0] & 0x8) {
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
 800201a:	ea41 2106 	orr.w	r1, r1, r6, lsl #8
        int16_t val_z = (out[6] << 8) | out[5];
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
 800201e:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
    (void)f;
    i2cReleaseBus(&I2CD1);
    if (out[0] & 0x8) {
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
        int16_t val_z = (out[6] << 8) | out[5];
 8002022:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    msg_t f = i2cMasterTransmitTimeout(&I2CD1, 0x19, &start_reg, 1, out, 7, TIME_INFINITE);
    (void)f;
    i2cReleaseBus(&I2CD1);
    if (out[0] & 0x8) {
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
 8002026:	b209      	sxth	r1, r1
        int16_t val_z = (out[6] << 8) | out[5];
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
 8002028:	b212      	sxth	r2, r2
    (void)f;
    i2cReleaseBus(&I2CD1);
    if (out[0] & 0x8) {
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
        int16_t val_z = (out[6] << 8) | out[5];
 800202a:	b21b      	sxth	r3, r3
 800202c:	ee07 3a90 	vmov	s15, r3
    msg_t f = i2cMasterTransmitTimeout(&I2CD1, 0x19, &start_reg, 1, out, 7, TIME_INFINITE);
    (void)f;
    i2cReleaseBus(&I2CD1);
    if (out[0] & 0x8) {
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
 8002030:	ee06 1a10 	vmov	s12, r1
        int16_t val_z = (out[6] << 8) | out[5];
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
 8002034:	ee06 2a90 	vmov	s13, r2
        data[1] = ((float)val_y)*(4.0/(65535.0))*9.81;
        data[2] = ((float)val_z)*(4.0/(65535.0))*9.81;
 8002038:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
        int16_t val_z = (out[6] << 8) | out[5];
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
        data[1] = ((float)val_y)*(4.0/(65535.0))*9.81;
 800203c:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
    if (out[0] & 0x8) {
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
        int16_t val_z = (out[6] << 8) | out[5];
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
 8002040:	eef8 6ae6 	vcvt.f32.s32	s13, s13
        data[1] = ((float)val_y)*(4.0/(65535.0))*9.81;
        data[2] = ((float)val_z)*(4.0/(65535.0))*9.81;
 8002044:	ee67 7a05 	vmul.f32	s15, s14, s10
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
        int16_t val_z = (out[6] << 8) | out[5];
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
        data[1] = ((float)val_y)*(4.0/(65535.0))*9.81;
 8002048:	ee26 6a05 	vmul.f32	s12, s12, s10
    if (out[0] & 0x8) {
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
        int16_t val_z = (out[6] << 8) | out[5];
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
 800204c:	ee66 6a85 	vmul.f32	s13, s13, s10
        data[1] = ((float)val_y)*(4.0/(65535.0))*9.81;
 8002050:	ee26 6a25 	vmul.f32	s12, s12, s11
    if (out[0] & 0x8) {
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
        int16_t val_z = (out[6] << 8) | out[5];
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
 8002054:	ee26 7aa5 	vmul.f32	s14, s13, s11
        data[1] = ((float)val_y)*(4.0/(65535.0))*9.81;
        data[2] = ((float)val_z)*(4.0/(65535.0))*9.81;
 8002058:	ee67 7aa5 	vmul.f32	s15, s15, s11
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
        int16_t val_z = (out[6] << 8) | out[5];
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
        data[1] = ((float)val_y)*(4.0/(65535.0))*9.81;
 800205c:	ed80 6a01 	vstr	s12, [r0, #4]
    if (out[0] & 0x8) {
        int16_t val_x = (out[2] << 8) | out[1];
        int16_t val_y = (out[4] << 8) | out[3];
        int16_t val_z = (out[6] << 8) | out[5];
        // Accel scale is +- 2.0g
        data[0] = ((float)val_x)*(4.0/(65535.0))*9.81;
 8002060:	ed80 7a00 	vstr	s14, [r0]
        data[1] = ((float)val_y)*(4.0/(65535.0))*9.81;
        data[2] = ((float)val_z)*(4.0/(65535.0))*9.81;
 8002064:	edc0 7a02 	vstr	s15, [r0, #8]
//					pwmEnableChannel(&PWMD4, 0, 1350);
//				}
//			//}
//				chThdSleepMilliseconds(100);
//	}
}
 8002068:	b006      	add	sp, #24
 800206a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800206e:	bf00      	nop
 8002070:	20001354 	.word	0x20001354
 8002074:	38800080 	.word	0x38800080
 8002078:	411cf5c3 	.word	0x411cf5c3
 800207c:	200009f0 	.word	0x200009f0

08002080 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8002080:	4b1b      	ldr	r3, [pc, #108]	; (80020f0 <main+0x70>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002082:	481c      	ldr	r0, [pc, #112]	; (80020f4 <main+0x74>)
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8002084:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002086:	f04f 31ff 	mov.w	r1, #4294967295
 800208a:	2200      	movs	r2, #0
			break;
		}
		chThdSleepMilliseconds(100);
	}
}
int main(void) {
 800208c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8002090:	6299      	str	r1, [r3, #40]	; 0x28
 8002092:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8002094:	691c      	ldr	r4, [r3, #16]
 8002096:	6119      	str	r1, [r3, #16]
 8002098:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 800209a:	68dc      	ldr	r4, [r3, #12]
 800209c:	60d9      	str	r1, [r3, #12]
 800209e:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80020a0:	69d9      	ldr	r1, [r3, #28]
 80020a2:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80020a6:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80020a8:	6801      	ldr	r1, [r0, #0]
 80020aa:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80020ae:	6001      	str	r1, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 80020b0:	6a19      	ldr	r1, [r3, #32]
 80020b2:	f401 7140 	and.w	r1, r1, #768	; 0x300
 80020b6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80020ba:	b08b      	sub	sp, #44	; 0x2c
 80020bc:	d003      	beq.n	80020c6 <main+0x46>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80020be:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 80020c2:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 80020c4:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 80020c6:	4b0a      	ldr	r3, [pc, #40]	; (80020f0 <main+0x70>)
 80020c8:	6a1a      	ldr	r2, [r3, #32]
 80020ca:	0412      	lsls	r2, r2, #16
 80020cc:	d407      	bmi.n	80020de <main+0x5e>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 80020ce:	6a1a      	ldr	r2, [r3, #32]
 80020d0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80020d4:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 80020d6:	6a1a      	ldr	r2, [r3, #32]
 80020d8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80020dc:	621a      	str	r2, [r3, #32]
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 80020de:	4806      	ldr	r0, [pc, #24]	; (80020f8 <main+0x78>)
 80020e0:	4906      	ldr	r1, [pc, #24]	; (80020fc <main+0x7c>)
 80020e2:	4b07      	ldr	r3, [pc, #28]	; (8002100 <main+0x80>)
 80020e4:	4c07      	ldr	r4, [pc, #28]	; (8002104 <main+0x84>)
 80020e6:	2200      	movs	r2, #0
 80020e8:	6002      	str	r2, [r0, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
 80020ea:	4610      	mov	r0, r2
 80020ec:	e00d      	b.n	800210a <main+0x8a>
 80020ee:	bf00      	nop
 80020f0:	40021000 	.word	0x40021000
 80020f4:	40007000 	.word	0x40007000
 80020f8:	20001350 	.word	0x20001350
 80020fc:	08002ce0 	.word	0x08002ce0
 8002100:	40020008 	.word	0x40020008
 8002104:	20001098 	.word	0x20001098
 8002108:	684b      	ldr	r3, [r1, #4]
 800210a:	6018      	str	r0, [r3, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 800210c:	f844 0032 	str.w	r0, [r4, r2, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8002110:	3201      	adds	r2, #1
 8002112:	2a0c      	cmp	r2, #12
 8002114:	f101 0114 	add.w	r1, r1, #20
    _stm32_dma_streams[i].channel->CCR = 0U;
 8002118:	f04f 0300 	mov.w	r3, #0
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800211c:	d1f4      	bne.n	8002108 <main+0x88>
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 800211e:	4dbf      	ldr	r5, [pc, #764]	; (800241c <main+0x39c>)
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8002120:	4cbf      	ldr	r4, [pc, #764]	; (8002420 <main+0x3a0>)
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8002122:	f8df e36c 	ldr.w	lr, [pc, #876]	; 8002490 <main+0x410>

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8002126:	48bf      	ldr	r0, [pc, #764]	; (8002424 <main+0x3a4>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8002128:	f8df 9368 	ldr.w	r9, [pc, #872]	; 8002494 <main+0x414>
  gpiop->PUPDR   = config->pupdr;
 800212c:	f8df a368 	ldr.w	sl, [pc, #872]	; 8002498 <main+0x418>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002130:	4fbd      	ldr	r7, [pc, #756]	; (8002428 <main+0x3a8>)
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8002132:	4ebe      	ldr	r6, [pc, #760]	; (800242c <main+0x3ac>)
#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
#if STM32_I2C_USE_DMA == TRUE
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8002134:	f8df c364 	ldr.w	ip, [pc, #868]	; 800249c <main+0x41c>
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8002138:	4abd      	ldr	r2, [pc, #756]	; (8002430 <main+0x3b0>)
  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 800213a:	f04f 31ff 	mov.w	r1, #4294967295
 800213e:	6069      	str	r1, [r5, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8002140:	6061      	str	r1, [r4, #4]
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8002142:	f8de 1018 	ldr.w	r1, [lr, #24]
 8002146:	4dbb      	ldr	r5, [pc, #748]	; (8002434 <main+0x3b4>)
 8002148:	4cbb      	ldr	r4, [pc, #748]	; (8002438 <main+0x3b8>)
 800214a:	f041 0101 	orr.w	r1, r1, #1
 800214e:	f8ce 1018 	str.w	r1, [lr, #24]

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8002152:	6801      	ldr	r1, [r0, #0]
 8002154:	f041 0120 	orr.w	r1, r1, #32
 8002158:	6001      	str	r1, [r0, #0]
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 800215a:	f8de 8014 	ldr.w	r8, [lr, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800215e:	48b7      	ldr	r0, [pc, #732]	; (800243c <main+0x3bc>)
 8002160:	49b7      	ldr	r1, [pc, #732]	; (8002440 <main+0x3c0>)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8002162:	f448 08fc 	orr.w	r8, r8, #8257536	; 0x7e0000
 8002166:	f8ce 8014 	str.w	r8, [lr, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800216a:	f04f 4e90 	mov.w	lr, #1207959552	; 0x48000000
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800216e:	f64f 78ff 	movw	r8, #65535	; 0xffff
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002172:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002176:	f8ce 9008 	str.w	r9, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 800217a:	f8df 9324 	ldr.w	r9, [pc, #804]	; 80024a0 <main+0x420>

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800217e:	f8ce a00c 	str.w	sl, [lr, #12]
  gpiop->ODR     = config->odr;
 8002182:	f8ce 8014 	str.w	r8, [lr, #20]
  gpiop->AFRL    = config->afrl;
 8002186:	f8ce 9020 	str.w	r9, [lr, #32]
  gpiop->AFRH    = config->afrh;
 800218a:	f44f 296e 	mov.w	r9, #974848	; 0xee000
 800218e:	f8ce 9024 	str.w	r9, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002192:	f8df 9310 	ldr.w	r9, [pc, #784]	; 80024a4 <main+0x424>
 8002196:	f8ce 9000 	str.w	r9, [lr]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800219a:	f04f 0ec0 	mov.w	lr, #192	; 0xc0
  gpiop->OSPEEDR = config->ospeedr;
 800219e:	f24f 09c0 	movw	r9, #61632	; 0xf0c0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80021a2:	f8c7 e004 	str.w	lr, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80021a6:	f8c7 9008 	str.w	r9, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 80021aa:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 80024a8 <main+0x428>
 80021ae:	f8c7 900c 	str.w	r9, [r7, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80021b2:	f04f 4988 	mov.w	r9, #1140850688	; 0x44000000
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80021b6:	f8c7 8014 	str.w	r8, [r7, #20]
  gpiop->AFRL    = config->afrl;
 80021ba:	f8c7 9020 	str.w	r9, [r7, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80021be:	f24a 0980 	movw	r9, #41088	; 0xa080
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 80021c2:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80021c4:	f8c7 9000 	str.w	r9, [r7]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80021c8:	f04f 4770 	mov.w	r7, #4026531840	; 0xf0000000
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80021cc:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80021ce:	60af      	str	r7, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 80021d0:	4f9c      	ldr	r7, [pc, #624]	; (8002444 <main+0x3c4>)
 80021d2:	60ef      	str	r7, [r5, #12]
  gpiop->ODR     = config->odr;
 80021d4:	f8c5 8014 	str.w	r8, [r5, #20]
  gpiop->AFRL    = config->afrl;
 80021d8:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
 80021da:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80021dc:	602b      	str	r3, [r5, #0]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80021de:	f04f 3555 	mov.w	r5, #1431655765	; 0x55555555
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80021e2:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80021e4:	60a3      	str	r3, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 80021e6:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 80021e8:	f8c4 8014 	str.w	r8, [r4, #20]
  gpiop->AFRL    = config->afrl;
 80021ec:	6223      	str	r3, [r4, #32]
  i2cp->config = NULL;
 80021ee:	6073      	str	r3, [r6, #4]
  gpiop->AFRH    = config->afrh;
 80021f0:	6263      	str	r3, [r4, #36]	; 0x24
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 80021f2:	6173      	str	r3, [r6, #20]
  gpiop->MODER   = config->moder;
 80021f4:	6023      	str	r3, [r4, #0]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80021f6:	4c94      	ldr	r4, [pc, #592]	; (8002448 <main+0x3c8>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80021f8:	6043      	str	r3, [r0, #4]
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 80021fa:	61f3      	str	r3, [r6, #28]
  gpiop->OSPEEDR = config->ospeedr;
 80021fc:	6084      	str	r4, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 80021fe:	4c93      	ldr	r4, [pc, #588]	; (800244c <main+0x3cc>)
 8002200:	60c4      	str	r4, [r0, #12]
 *
 * @init
 */
void icuObjectInit(ICUDriver *icup) {

  icup->state  = ICU_STOP;
 8002202:	4f93      	ldr	r7, [pc, #588]	; (8002450 <main+0x3d0>)
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8002204:	4d93      	ldr	r5, [pc, #588]	; (8002454 <main+0x3d4>)
 */
void spi_lld_init(void) {

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
 8002206:	f8df 92a4 	ldr.w	r9, [pc, #676]	; 80024ac <main+0x42c>
  gpiop->ODR     = config->odr;
 800220a:	24ff      	movs	r4, #255	; 0xff
 800220c:	6144      	str	r4, [r0, #20]
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800220e:	4c92      	ldr	r4, [pc, #584]	; (8002458 <main+0x3d8>)

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8002210:	6203      	str	r3, [r0, #32]
  I2CD1.i2c    = I2C1;
#if STM32_I2C_USE_DMA == TRUE
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8002212:	f8c6 c028 	str.w	ip, [r6, #40]	; 0x28
  gpiop->AFRH    = config->afrh;
 8002216:	6243      	str	r3, [r0, #36]	; 0x24
  icup->config = NULL;
 8002218:	607b      	str	r3, [r7, #4]
  gpiop->MODER   = config->moder;
 800221a:	6004      	str	r4, [r0, #0]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800221c:	240f      	movs	r4, #15
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800221e:	604b      	str	r3, [r1, #4]
  pwmp->config   = NULL;
 8002220:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002222:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8002224:	4c8d      	ldr	r4, [pc, #564]	; (800245c <main+0x3dc>)
 8002226:	60cc      	str	r4, [r1, #12]
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 8002228:	4c8d      	ldr	r4, [pc, #564]	; (8002460 <main+0x3e0>)
  pwmp->enabled  = 0;
 800222a:	60eb      	str	r3, [r5, #12]
  gpiop->ODR     = config->odr;
 800222c:	f8c1 8014 	str.w	r8, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8002230:	620b      	str	r3, [r1, #32]
 8002232:	6334      	str	r4, [r6, #48]	; 0x30
#if STM32_I2C_USE_DMA == TRUE
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8002234:	f1ac 0414 	sub.w	r4, ip, #20
  gpiop->AFRH    = config->afrh;
 8002238:	624b      	str	r3, [r1, #36]	; 0x24
 800223a:	4610      	mov	r0, r2
 800223c:	62f4      	str	r4, [r6, #44]	; 0x2c
  gpiop->MODER   = config->moder;
 800223e:	600b      	str	r3, [r1, #0]
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8002240:	2401      	movs	r4, #1
void icu_lld_init(void) {

#if STM32_ICU_USE_TIM1
  /* Driver initialization.*/
  icuObjectInit(&ICUD1);
  ICUD1.tim = STM32_TIM1;
 8002242:	4988      	ldr	r1, [pc, #544]	; (8002464 <main+0x3e4>)
 8002244:	60f9      	str	r1, [r7, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002246:	f106 080c 	add.w	r8, r6, #12
 *
 * @init
 */
void icuObjectInit(ICUDriver *icup) {

  icup->state  = ICU_STOP;
 800224a:	703c      	strb	r4, [r7, #0]
 800224c:	4986      	ldr	r1, [pc, #536]	; (8002468 <main+0x3e8>)
 800224e:	f8c6 800c 	str.w	r8, [r6, #12]
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
  PWMD4.channels = STM32_TIM4_CHANNELS;
 8002252:	2704      	movs	r7, #4
  tqp->p_prev = (thread_t *)tqp;
 8002254:	f8c6 8010 	str.w	r8, [r6, #16]
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8002258:	702c      	strb	r4, [r5, #0]
 800225a:	7034      	strb	r4, [r6, #0]
 800225c:	742f      	strb	r7, [r5, #16]
 800225e:	f840 1b04 	str.w	r1, [r0], #4

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002262:	4f82      	ldr	r7, [pc, #520]	; (800246c <main+0x3ec>)
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8002264:	6153      	str	r3, [r2, #20]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8002266:	f04f 0810 	mov.w	r8, #16
 800226a:	f8c2 8038 	str.w	r8, [r2, #56]	; 0x38
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 800226e:	6050      	str	r0, [r2, #4]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8002270:	7214      	strb	r4, [r2, #8]
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8002272:	6293      	str	r3, [r2, #40]	; 0x28
  iqp->q_link    = link;
 8002274:	62d2      	str	r2, [r2, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8002276:	6512      	str	r2, [r2, #80]	; 0x50
 8002278:	f887 e325 	strb.w	lr, [r7, #805]	; 0x325
  PWMD4.tim = STM32_TIM4;
 800227c:	f8df e230 	ldr.w	lr, [pc, #560]	; 80024b0 <main+0x430>
 8002280:	f8c5 e018 	str.w	lr, [r5, #24]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8002284:	f102 0574 	add.w	r5, r2, #116	; 0x74
  oqp->q_notify  = onfy;
 8002288:	f8df e228 	ldr.w	lr, [pc, #552]	; 80024b4 <main+0x434>
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 800228c:	6415      	str	r5, [r2, #64]	; 0x40
  oqp->q_notify  = onfy;
 800228e:	f8c2 e04c 	str.w	lr, [r2, #76]	; 0x4c
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 8002292:	4d77      	ldr	r5, [pc, #476]	; (8002470 <main+0x3f0>)
  SD1.clock = STM32_USART1CLK;
 8002294:	f8df e220 	ldr.w	lr, [pc, #544]	; 80024b8 <main+0x438>
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 8002298:	4976      	ldr	r1, [pc, #472]	; (8002474 <main+0x3f4>)
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 800229a:	6755      	str	r5, [r2, #116]	; 0x74
  SD1.clock = STM32_USART1CLK;
 800229c:	f8c2 e078 	str.w	lr, [r2, #120]	; 0x78
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80022a0:	2520      	movs	r5, #32
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80022a2:	f102 0e0c 	add.w	lr, r2, #12
 80022a6:	f8c7 5184 	str.w	r5, [r7, #388]	; 0x184
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 80022aa:	4873      	ldr	r0, [pc, #460]	; (8002478 <main+0x3f8>)
 80022ac:	f8c2 e00c 	str.w	lr, [r2, #12]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80022b0:	607d      	str	r5, [r7, #4]
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 80022b2:	f102 0564 	add.w	r5, r2, #100	; 0x64
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80022b6:	f102 0754 	add.w	r7, r2, #84	; 0x54
  tqp->p_prev = (thread_t *)tqp;
 80022ba:	f8c2 e010 	str.w	lr, [r2, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80022be:	f102 0e30 	add.w	lr, r2, #48	; 0x30
 80022c2:	6197      	str	r7, [r2, #24]
  iqp->q_rdptr   = bp;
 80022c4:	6257      	str	r7, [r2, #36]	; 0x24
  iqp->q_wrptr   = bp;
 80022c6:	6217      	str	r7, [r2, #32]
  iqp->q_top     = bp + size;
 80022c8:	61d5      	str	r5, [r2, #28]
 80022ca:	f101 070c 	add.w	r7, r1, #12
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 80022ce:	63d5      	str	r5, [r2, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 80022d0:	6495      	str	r5, [r2, #72]	; 0x48
  oqp->q_wrptr   = bp;
 80022d2:	6455      	str	r5, [r2, #68]	; 0x44
 80022d4:	f8c2 e030 	str.w	lr, [r2, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 80022d8:	f8c2 e034 	str.w	lr, [r2, #52]	; 0x34
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 80022dc:	f1ac 0864 	sub.w	r8, ip, #100	; 0x64
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 80022e0:	f1ac 0250 	sub.w	r2, ip, #80	; 0x50
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 80022e4:	f241 0e0a 	movw	lr, #4106	; 0x100a
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 80022e8:	f241 0518 	movw	r5, #4120	; 0x1018
 80022ec:	700c      	strb	r4, [r1, #0]
  spip->config = NULL;
 80022ee:	604b      	str	r3, [r1, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 80022f0:	608b      	str	r3, [r1, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80022f2:	60cf      	str	r7, [r1, #12]
  tqp->p_prev = (thread_t *)tqp;
 80022f4:	610f      	str	r7, [r1, #16]
 80022f6:	614b      	str	r3, [r1, #20]

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 80022f8:	624a      	str	r2, [r1, #36]	; 0x24
 */
void spi_lld_init(void) {

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
 80022fa:	f8c1 901c 	str.w	r9, [r1, #28]
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 80022fe:	f8c1 8020 	str.w	r8, [r1, #32]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8002302:	f8c1 e028 	str.w	lr, [r1, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8002306:	62cd      	str	r5, [r1, #44]	; 0x2c
 8002308:	7004      	strb	r4, [r0, #0]
  usbp->config       = NULL;
 800230a:	6043      	str	r3, [r0, #4]
 800230c:	f100 0228 	add.w	r2, r0, #40	; 0x28
 8002310:	f100 0144 	add.w	r1, r0, #68	; 0x44
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8002314:	f842 3f04 	str.w	r3, [r2, #4]!
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8002318:	4291      	cmp	r1, r2
    usbp->in_params[i]  = NULL;
 800231a:	f04f 0500 	mov.w	r5, #0
    usbp->out_params[i] = NULL;
 800231e:	61d3      	str	r3, [r2, #28]
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8002320:	d1f8      	bne.n	8002314 <main+0x294>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8002322:	f8df 916c 	ldr.w	r9, [pc, #364]	; 8002490 <main+0x410>

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8002326:	4c55      	ldr	r4, [pc, #340]	; (800247c <main+0x3fc>)

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8002328:	f8d9 301c 	ldr.w	r3, [r9, #28]
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 800232c:	8105      	strh	r5, [r0, #8]
 800232e:	f043 0301 	orr.w	r3, r3, #1
 8002332:	f8c9 301c 	str.w	r3, [r9, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8002336:	68a2      	ldr	r2, [r4, #8]
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8002338:	4951      	ldr	r1, [pc, #324]	; (8002480 <main+0x400>)
  usbp->receiving    = 0;
 800233a:	8145      	strh	r5, [r0, #10]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800233c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002340:	4f4a      	ldr	r7, [pc, #296]	; (800246c <main+0x3ec>)
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8002342:	f8df a178 	ldr.w	sl, [pc, #376]	; 80024bc <main+0x43c>

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8002346:	f8df 8178 	ldr.w	r8, [pc, #376]	; 80024c0 <main+0x440>
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800234a:	f8df c178 	ldr.w	ip, [pc, #376]	; 80024c4 <main+0x444>

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800234e:	f042 0201 	orr.w	r2, r2, #1

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002352:	f641 401f 	movw	r0, #7199	; 0x1c1f

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8002356:	60a2      	str	r2, [r4, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002358:	f04f 3eff 	mov.w	lr, #4294967295

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800235c:	6298      	str	r0, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800235e:	2201      	movs	r2, #1
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002360:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002364:	2480      	movs	r4, #128	; 0x80
  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002366:	f8c3 e02c 	str.w	lr, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 800236a:	619d      	str	r5, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 800236c:	635d      	str	r5, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 800236e:	60dd      	str	r5, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8002370:	605d      	str	r5, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002372:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002374:	601a      	str	r2, [r3, #0]
 8002376:	9203      	str	r2, [sp, #12]
 8002378:	f887 431c 	strb.w	r4, [r7, #796]	; 0x31c
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800237c:	f8c7 0180 	str.w	r0, [r7, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002380:	6038      	str	r0, [r7, #0]
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8002382:	608d      	str	r5, [r1, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8002384:	68c8      	ldr	r0, [r1, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002386:	4c3f      	ldr	r4, [pc, #252]	; (8002484 <main+0x404>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8002388:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800238c:	4003      	ands	r3, r0
  reg_value  =  (reg_value                                   |
 800238e:	ea43 0a0a 	orr.w	sl, r3, sl
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8002392:	f8c1 a00c 	str.w	sl, [r1, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8002396:	f8d8 300c 	ldr.w	r3, [r8, #12]
  tqp->p_prev = (thread_t *)tqp;
 800239a:	6064      	str	r4, [r4, #4]
 800239c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80023a0:	f8c8 300c 	str.w	r3, [r8, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80023a4:	f8dc 3000 	ldr.w	r3, [ip]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 80023a8:	60a5      	str	r5, [r4, #8]
 80023aa:	4313      	orrs	r3, r2
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80023ac:	f04f 0a10 	mov.w	sl, #16
 80023b0:	f8cc 3000 	str.w	r3, [ip]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 80023b4:	eb0d 000a 	add.w	r0, sp, sl
 80023b8:	f881 a01f 	strb.w	sl, [r1, #31]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80023bc:	f104 031c 	add.w	r3, r4, #28
 80023c0:	f04f 0820 	mov.w	r8, #32

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80023c4:	f04f 0a00 	mov.w	sl, #0
 80023c8:	f04f 0b00 	mov.w	fp, #0
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 80023cc:	6124      	str	r4, [r4, #16]
 80023ce:	f881 8022 	strb.w	r8, [r1, #34]	; 0x22
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80023d2:	6024      	str	r4, [r4, #0]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 80023d4:	6164      	str	r4, [r4, #20]
 80023d6:	61e3      	str	r3, [r4, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 80023d8:	6223      	str	r3, [r4, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 80023da:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 80023de:	f8cd e010 	str.w	lr, [sp, #16]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80023e2:	e9cd ab08 	strd	sl, fp, [sp, #32]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 80023e6:	62a5      	str	r5, [r4, #40]	; 0x28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 80023e8:	6765      	str	r5, [r4, #116]	; 0x74
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 80023ea:	9505      	str	r5, [sp, #20]
  tmp->last       = (rtcnt_t)0;
 80023ec:	9506      	str	r5, [sp, #24]
  tmp->n          = (ucnt_t)0;
 80023ee:	9507      	str	r5, [sp, #28]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 80023f0:	f000 f9ce 	bl	8002790 <chTMStartMeasurementX.constprop.42>
  chTMStopMeasurementX(&tm);
 80023f4:	a804      	add	r0, sp, #16
 80023f6:	f7fe fbcb 	bl	8000b90 <chTMStopMeasurementX>
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 80023fa:	4b23      	ldr	r3, [pc, #140]	; (8002488 <main+0x408>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80023fc:	4923      	ldr	r1, [pc, #140]	; (800248c <main+0x40c>)
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80023fe:	f8d4 c014 	ldr.w	ip, [r4, #20]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002402:	9a03      	ldr	r2, [sp, #12]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002404:	f8c4 c044 	str.w	ip, [r4, #68]	; 0x44
 8002408:	f103 0a10 	add.w	sl, r3, #16
 800240c:	f021 0e07 	bic.w	lr, r1, #7
  ch.tm.offset = tm.last;
 8002410:	9906      	ldr	r1, [sp, #24]
 8002412:	f8c3 a010 	str.w	sl, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 8002416:	f8c3 a014 	str.w	sl, [r3, #20]
 800241a:	e055      	b.n	80024c8 <main+0x448>
 800241c:	40020000 	.word	0x40020000
 8002420:	40020400 	.word	0x40020400
 8002424:	40010000 	.word	0x40010000
 8002428:	48000400 	.word	0x48000400
 800242c:	20001354 	.word	0x20001354
 8002430:	200010f8 	.word	0x200010f8
 8002434:	48000800 	.word	0x48000800
 8002438:	48000c00 	.word	0x48000c00
 800243c:	48001000 	.word	0x48001000
 8002440:	48001400 	.word	0x48001400
 8002444:	05555555 	.word	0x05555555
 8002448:	ffff00c0 	.word	0xffff00c0
 800244c:	01155515 	.word	0x01155515
 8002450:	20001080 	.word	0x20001080
 8002454:	20000a2c 	.word	0x20000a2c
 8002458:	55550040 	.word	0x55550040
 800245c:	55555550 	.word	0x55555550
 8002460:	40005400 	.word	0x40005400
 8002464:	40012c00 	.word	0x40012c00
 8002468:	08002cb0 	.word	0x08002cb0
 800246c:	e000e100 	.word	0xe000e100
 8002470:	40013800 	.word	0x40013800
 8002474:	200009fc 	.word	0x200009fc
 8002478:	20000a48 	.word	0x20000a48
 800247c:	e0042000 	.word	0xe0042000
 8002480:	e000ed00 	.word	0xe000ed00
 8002484:	20001178 	.word	0x20001178
 8002488:	20000e90 	.word	0x20000e90
 800248c:	2000138f 	.word	0x2000138f
 8002490:	40021000 	.word	0x40021000
 8002494:	3cc0fc00 	.word	0x3cc0fc00
 8002498:	64151154 	.word	0x64151154
 800249c:	08002d58 	.word	0x08002d58
 80024a0:	55500000 	.word	0x55500000
 80024a4:	2a80a800 	.word	0x2a80a800
 80024a8:	55550515 	.word	0x55550515
 80024ac:	40013000 	.word	0x40013000
 80024b0:	40000800 	.word	0x40000800
 80024b4:	08001141 	.word	0x08001141
 80024b8:	02255100 	.word	0x02255100
 80024bc:	05fa0300 	.word	0x05fa0300
 80024c0:	e000edf0 	.word	0xe000edf0
 80024c4:	e0001000 	.word	0xe0001000
 80024c8:	6761      	str	r1, [r4, #116]	; 0x74
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80024ca:	f04f 0a40 	mov.w	sl, #64	; 0x40
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80024ce:	f104 0130 	add.w	r1, r4, #48	; 0x30
 80024d2:	619d      	str	r5, [r3, #24]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80024d4:	f8c4 a038 	str.w	sl, [r4, #56]	; 0x38
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80024d8:	f8c4 a06c 	str.w	sl, [r4, #108]	; 0x6c
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80024dc:	f884 504d 	strb.w	r5, [r4, #77]	; 0x4d
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80024e0:	66a5      	str	r5, [r4, #104]	; 0x68
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 80024e2:	6665      	str	r5, [r4, #100]	; 0x64
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80024e4:	f884 204e 	strb.w	r2, [r4, #78]	; 0x4e
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80024e8:	64a5      	str	r5, [r4, #72]	; 0x48
  REG_INSERT(tp);
 80024ea:	6424      	str	r4, [r4, #64]	; 0x40
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80024ec:	486d      	ldr	r0, [pc, #436]	; (80026a4 <main+0x624>)
 80024ee:	f8cc 1010 	str.w	r1, [ip, #16]
 80024f2:	6161      	str	r1, [r4, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80024f4:	61a1      	str	r1, [r4, #24]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80024f6:	f104 0154 	add.w	r1, r4, #84	; 0x54
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80024fa:	f8df a1e4 	ldr.w	sl, [pc, #484]	; 80026e0 <main+0x660>
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80024fe:	f8df c1e4 	ldr.w	ip, [pc, #484]	; 80026e4 <main+0x664>
 8002502:	6561      	str	r1, [r4, #84]	; 0x54
 8002504:	4968      	ldr	r1, [pc, #416]	; (80026a8 <main+0x628>)
  default_heap.h_free.h.u.next = NULL;
 8002506:	609d      	str	r5, [r3, #8]
 8002508:	f020 0007 	bic.w	r0, r0, #7
  default_heap.h_free.h.size = 0;
 800250c:	60dd      	str	r5, [r3, #12]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 800250e:	6019      	str	r1, [r3, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002510:	f104 0358 	add.w	r3, r4, #88	; 0x58
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8002514:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
 8002518:	65a3      	str	r3, [r4, #88]	; 0x58
  tqp->p_prev = (thread_t *)tqp;
 800251a:	65e3      	str	r3, [r4, #92]	; 0x5c
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 800251c:	f8ca e000 	str.w	lr, [sl]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002520:	f8cc 0000 	str.w	r0, [ip]
 8002524:	f385 8811 	msr	BASEPRI, r5
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002528:	b662      	cpsie	i
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 800252a:	69a3      	ldr	r3, [r4, #24]
 800252c:	495f      	ldr	r1, [pc, #380]	; (80026ac <main+0x62c>)
 800252e:	6199      	str	r1, [r3, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8002530:	f104 0078 	add.w	r0, r4, #120	; 0x78
 8002534:	4b5e      	ldr	r3, [pc, #376]	; (80026b0 <main+0x630>)
 8002536:	f44f 71b0 	mov.w	r1, #352	; 0x160
 800253a:	f000 f8d9 	bl	80026f0 <chThdCreateStatic.constprop.44>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 800253e:	4b5d      	ldr	r3, [pc, #372]	; (80026b4 <main+0x634>)
 8002540:	6183      	str	r3, [r0, #24]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002542:	f388 8811 	msr	BASEPRI, r8
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8002546:	6b34      	ldr	r4, [r6, #48]	; 0x30

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8002548:	f896 a000 	ldrb.w	sl, [r6]
  i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
#endif

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
 800254c:	6823      	ldr	r3, [r4, #0]
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 800254e:	4a5a      	ldr	r2, [pc, #360]	; (80026b8 <main+0x638>)
 8002550:	6072      	str	r2, [r6, #4]
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

#if STM32_I2C_USE_DMA == TRUE
  /* Common DMA modes.*/
  i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
 8002552:	219a      	movs	r1, #154	; 0x9a
  i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
 8002554:	228a      	movs	r2, #138	; 0x8a
#endif

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
 8002556:	f023 0301 	bic.w	r3, r3, #1

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 800255a:	f1ba 0f01 	cmp.w	sl, #1
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

#if STM32_I2C_USE_DMA == TRUE
  /* Common DMA modes.*/
  i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
 800255e:	6271      	str	r1, [r6, #36]	; 0x24
  i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
 8002560:	6232      	str	r2, [r6, #32]
 8002562:	f8df 8184 	ldr.w	r8, [pc, #388]	; 80026e8 <main+0x668>
#endif

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
 8002566:	6023      	str	r3, [r4, #0]

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8002568:	d062      	beq.n	8002630 <main+0x5b0>
 800256a:	4854      	ldr	r0, [pc, #336]	; (80026bc <main+0x63c>)
 800256c:	f24c 0390 	movw	r3, #49296	; 0xc090
#endif /* STM32_I2C_USE_I2C4 */
  }

#if STM32_I2C_USE_DMA == TRUE
  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->RXDR);
 8002570:	6ab1      	ldr	r1, [r6, #40]	; 0x28
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->TXDR);
 8002572:	6af2      	ldr	r2, [r6, #44]	; 0x2c
#endif /* STM32_I2C_USE_I2C4 */
  }

#if STM32_I2C_USE_DMA == TRUE
  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->RXDR);
 8002574:	6849      	ldr	r1, [r1, #4]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->TXDR);
 8002576:	6852      	ldr	r2, [r2, #4]
#endif /* STM32_I2C_USE_I2C4 */
  }

#if STM32_I2C_USE_DMA == TRUE
  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->RXDR);
 8002578:	f8df 816c 	ldr.w	r8, [pc, #364]	; 80026e8 <main+0x668>
 800257c:	f104 0524 	add.w	r5, r4, #36	; 0x24
 8002580:	608d      	str	r5, [r1, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->TXDR);
 8002582:	f104 0128 	add.w	r1, r4, #40	; 0x28
 8002586:	6091      	str	r1, [r2, #8]
#endif

  /* Reset i2c peripheral, the TCIE bit will be handled separately.*/
  dp->CR1 = i2cp->config->cr1 |
 8002588:	6023      	str	r3, [r4, #0]
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;

  /* Setup I2C parameters.*/
  dp->TIMINGR = i2cp->config->timingr;
 800258a:	6120      	str	r0, [r4, #16]

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 800258c:	6823      	ldr	r3, [r4, #0]
  i2c_lld_start(i2cp);
  i2cp->state = I2C_READY;
 800258e:	2502      	movs	r5, #2
 8002590:	f043 0301 	orr.w	r3, r3, #1
 8002594:	6023      	str	r3, [r4, #0]
 8002596:	2400      	movs	r4, #0
 8002598:	7035      	strb	r5, [r6, #0]
 800259a:	f384 8811 	msr	BASEPRI, r4
  0,
  0
};

static void writeByteI2C(uint8_t addr, uint8_t reg, uint8_t val){
    uint8_t cmd[] = {reg, val};
 800259e:	2397      	movs	r3, #151	; 0x97
 80025a0:	2720      	movs	r7, #32
 80025a2:	f88d 3011 	strb.w	r3, [sp, #17]
 80025a6:	f88d 7010 	strb.w	r7, [sp, #16]
 80025aa:	f387 8811 	msr	BASEPRI, r7
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 80025ae:	f000 f8f7 	bl	80027a0 <chMtxLockS.constprop.38>
 80025b2:	f384 8811 	msr	BASEPRI, r4
 80025b6:	f387 8811 	msr	BASEPRI, r7

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 80025ba:	2703      	movs	r7, #3
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 80025bc:	4623      	mov	r3, r4
 80025be:	9400      	str	r4, [sp, #0]
 80025c0:	a904      	add	r1, sp, #16
 80025c2:	462a      	mov	r2, r5
 80025c4:	2019      	movs	r0, #25
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 80025c6:	60b4      	str	r4, [r6, #8]
  i2cp->state = I2C_ACTIVE_TX;
 80025c8:	7037      	strb	r7, [r6, #0]
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 80025ca:	f000 fa11 	bl	80029f0 <i2c_lld_master_transmit_timeout.constprop.20>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 80025ce:	3001      	adds	r0, #1
    i2cp->state = I2C_LOCKED;
 80025d0:	bf06      	itte	eq
 80025d2:	2305      	moveq	r3, #5
 80025d4:	f888 3000 	strbeq.w	r3, [r8]
  }
  else {
    i2cp->state = I2C_READY;
 80025d8:	f888 5000 	strbne.w	r5, [r8]
 80025dc:	2400      	movs	r4, #0
 80025de:	f384 8811 	msr	BASEPRI, r4
 80025e2:	f000 f94d 	bl	8002880 <chMtxUnlock.constprop.36>
    halInit();
    chSysInit();
	i2cStart(&I2CD1, &i2cconfig);
	initGyro();

	setState(RollOcm, DirectInput);
 80025e6:	4621      	mov	r1, r4
 80025e8:	2003      	movs	r0, #3
 80025ea:	f7ff fb31 	bl	8001c50 <setState>

    //palSetPadMode(GPIOD, 12, PAL_MODE_ALTERNATE(2));

    //tasks init
    chThdCreateStatic(waGyrosTask, sizeof(waGyrosTask), NORMALPRIO+1, GyrosTask, NULL);
 80025ee:	4b34      	ldr	r3, [pc, #208]	; (80026c0 <main+0x640>)
 80025f0:	4834      	ldr	r0, [pc, #208]	; (80026c4 <main+0x644>)
 80025f2:	2241      	movs	r2, #65	; 0x41
 80025f4:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80025f8:	f000 f87a 	bl	80026f0 <chThdCreateStatic.constprop.44>
    chThdCreateStatic(waRollAssisTask, sizeof(waRollAssisTask), NORMALPRIO+2, RollAssisTask, NULL);
 80025fc:	4b32      	ldr	r3, [pc, #200]	; (80026c8 <main+0x648>)
 80025fe:	4833      	ldr	r0, [pc, #204]	; (80026cc <main+0x64c>)
 8002600:	2242      	movs	r2, #66	; 0x42
 8002602:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8002606:	f000 f873 	bl	80026f0 <chThdCreateStatic.constprop.44>
//    chThdCreateStatic(waOcmTask, sizeof(waOcmTask), NORMALPRIO+3, OcmTask, NULL);
    chThdCreateStatic(waAltAssisTask, sizeof(waAltAssisTask), NORMALPRIO+4, AltAssisTask, NULL);
 800260a:	4b31      	ldr	r3, [pc, #196]	; (80026d0 <main+0x650>)
 800260c:	4831      	ldr	r0, [pc, #196]	; (80026d4 <main+0x654>)
 800260e:	2244      	movs	r2, #68	; 0x44
 8002610:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8002614:	f000 f86c 	bl	80026f0 <chThdCreateStatic.constprop.44>
    chThdCreateStatic(waModeTask, sizeof(waModeTask), NORMALPRIO+5, ModeTask, NULL);
 8002618:	4b2f      	ldr	r3, [pc, #188]	; (80026d8 <main+0x658>)
 800261a:	4830      	ldr	r0, [pc, #192]	; (80026dc <main+0x65c>)
 800261c:	2245      	movs	r2, #69	; 0x45
 800261e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8002622:	f000 f865 	bl	80026f0 <chThdCreateStatic.constprop.44>
    while (TRUE) {

    	/*if(palReadPad(GPIOA, GPIOA_BUTTON)==0){
    		palSetPad(GPIOE, GPIOE_LED8_ORANGE);
    	}*/
    	chThdSleepMilliseconds(1000);
 8002626:	f242 7010 	movw	r0, #10000	; 0x2710
 800262a:	f7fe fce1 	bl	8000ff0 <chThdSleep>
 800262e:	e7fa      	b.n	8002626 <main+0x5a6>
  if (i2cp->state == I2C_STOP) {

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {

      rccResetI2C1();
 8002630:	f8d9 3010 	ldr.w	r3, [r9, #16]
      rccEnableI2C1(FALSE);
#if STM32_I2C_USE_DMA == TRUE
      {
        bool b;

        b = dmaStreamAllocate(i2cp->dmarx,
 8002634:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
  if (i2cp->state == I2C_STOP) {

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {

      rccResetI2C1();
 8002638:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800263c:	f8c9 3010 	str.w	r3, [r9, #16]
 8002640:	f8c9 5010 	str.w	r5, [r9, #16]
      rccEnableI2C1(FALSE);
 8002644:	f8d9 301c 	ldr.w	r3, [r9, #28]
 8002648:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800264c:	f8c9 301c 	str.w	r3, [r9, #28]
#if STM32_I2C_USE_DMA == TRUE
      {
        bool b;

        b = dmaStreamAllocate(i2cp->dmarx,
 8002650:	f000 f98e 	bl	8002970 <dmaStreamAllocate.constprop.23>
                              STM32_I2C_I2C1_IRQ_PRIORITY,
                              NULL,
                              (void *)i2cp);
        osalDbgAssert(!b, "stream already allocated");
        b = dmaStreamAllocate(i2cp->dmatx,
 8002654:	f8d8 002c 	ldr.w	r0, [r8, #44]	; 0x2c
 8002658:	f000 f98a 	bl	8002970 <dmaStreamAllocate.constprop.23>
 800265c:	f8d8 0004 	ldr.w	r0, [r8, #4]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002660:	23a0      	movs	r3, #160	; 0xa0
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002662:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002666:	f887 331f 	strb.w	r3, [r7, #799]	; 0x31f
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800266a:	f8c7 2180 	str.w	r2, [r7, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800266e:	603a      	str	r2, [r7, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002670:	f887 3320 	strb.w	r3, [r7, #800]	; 0x320
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002674:	f8c7 a184 	str.w	sl, [r7, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002678:	f8c7 a004 	str.w	sl, [r7, #4]
 800267c:	6843      	ldr	r3, [r0, #4]
                              STM32_I2C_I2C1_IRQ_PRIORITY,
                              NULL,
                              (void *)i2cp);
        osalDbgAssert(!b, "stream already allocated");

        i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 800267e:	f8d8 1020 	ldr.w	r1, [r8, #32]
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
        i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 8002682:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 8002686:	6800      	ldr	r0, [r0, #0]
 8002688:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
                              STM32_I2C_I2C1_IRQ_PRIORITY,
                              NULL,
                              (void *)i2cp);
        osalDbgAssert(!b, "stream already allocated");

        i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 800268c:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
        i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 8002690:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8002694:	f043 0390 	orr.w	r3, r3, #144	; 0x90
                              STM32_I2C_I2C1_IRQ_PRIORITY,
                              NULL,
                              (void *)i2cp);
        osalDbgAssert(!b, "stream already allocated");

        i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 8002698:	f8c8 1020 	str.w	r1, [r8, #32]
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
        i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 800269c:	f8c8 2024 	str.w	r2, [r8, #36]	; 0x24
 80026a0:	e766      	b.n	8002570 <main+0x4f0>
 80026a2:	bf00      	nop
 80026a4:	2000a000 	.word	0x2000a000
 80026a8:	08000331 	.word	0x08000331
 80026ac:	08002c90 	.word	0x08002c90
 80026b0:	080003e1 	.word	0x080003e1
 80026b4:	08002dd0 	.word	0x08002dd0
 80026b8:	08002cd0 	.word	0x08002cd0
 80026bc:	00902025 	.word	0x00902025
 80026c0:	08001fa1 	.word	0x08001fa1
 80026c4:	20000ca8 	.word	0x20000ca8
 80026c8:	08001d51 	.word	0x08001d51
 80026cc:	20000820 	.word	0x20000820
 80026d0:	08001ec1 	.word	0x08001ec1
 80026d4:	20000ad8 	.word	0x20000ad8
 80026d8:	08001d41 	.word	0x08001d41
 80026dc:	20000eb0 	.word	0x20000eb0
 80026e0:	20000ad4 	.word	0x20000ad4
 80026e4:	20000ad0 	.word	0x20000ad0
 80026e8:	20001354 	.word	0x20001354
 80026ec:	00000000 	.word	0x00000000

080026f0 <chThdCreateStatic.constprop.44>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 80026f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80026f2:	4604      	mov	r4, r0
 80026f4:	2020      	movs	r0, #32
 80026f6:	f380 8811 	msr	BASEPRI, r0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80026fa:	3964      	subs	r1, #100	; 0x64
 80026fc:	4421      	add	r1, r4
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80026fe:	4d22      	ldr	r5, [pc, #136]	; (8002788 <chThdCreateStatic.constprop.44+0x98>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002700:	4f22      	ldr	r7, [pc, #136]	; (800278c <chThdCreateStatic.constprop.44+0x9c>)
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002702:	6968      	ldr	r0, [r5, #20]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8002704:	69ae      	ldr	r6, [r5, #24]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002706:	60e1      	str	r1, [r4, #12]
 8002708:	640b      	str	r3, [r1, #64]	; 0x40
 800270a:	2300      	movs	r3, #0
 800270c:	660f      	str	r7, [r1, #96]	; 0x60
 800270e:	644b      	str	r3, [r1, #68]	; 0x44
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002710:	2702      	movs	r7, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002712:	2101      	movs	r1, #1
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002714:	60a2      	str	r2, [r4, #8]
  tp->p_state = CH_STATE_WTSTART;
 8002716:	7727      	strb	r7, [r4, #28]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002718:	6160      	str	r0, [r4, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800271a:	7763      	strb	r3, [r4, #29]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800271c:	77a1      	strb	r1, [r4, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800271e:	6125      	str	r5, [r4, #16]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002720:	63e2      	str	r2, [r4, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8002722:	63a3      	str	r3, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002724:	6363      	str	r3, [r4, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002726:	61a3      	str	r3, [r4, #24]
  REG_INSERT(tp);
 8002728:	6104      	str	r4, [r0, #16]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 800272a:	6223      	str	r3, [r4, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800272c:	68b1      	ldr	r1, [r6, #8]
 800272e:	616c      	str	r4, [r5, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8002730:	f104 0028 	add.w	r0, r4, #40	; 0x28
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8002734:	f104 0724 	add.w	r7, r4, #36	; 0x24
 8002738:	428a      	cmp	r2, r1
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800273a:	6267      	str	r7, [r4, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800273c:	62a0      	str	r0, [r4, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 800273e:	62e0      	str	r0, [r4, #44]	; 0x2c
 8002740:	d80f      	bhi.n	8002762 <chThdCreateStatic.constprop.44+0x72>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8002742:	7723      	strb	r3, [r4, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8002744:	462b      	mov	r3, r5
  do {
    cp = cp->p_next;
 8002746:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8002748:	6899      	ldr	r1, [r3, #8]
 800274a:	428a      	cmp	r2, r1
 800274c:	d9fb      	bls.n	8002746 <chThdCreateStatic.constprop.44+0x56>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800274e:	685a      	ldr	r2, [r3, #4]
 8002750:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8002752:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8002754:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8002756:	605c      	str	r4, [r3, #4]
 8002758:	2300      	movs	r3, #0
 800275a:	f383 8811 	msr	BASEPRI, r3
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
  chSysUnlock();

  return tp;
}
 800275e:	4620      	mov	r0, r4
 8002760:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8002762:	7733      	strb	r3, [r6, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8002764:	462b      	mov	r3, r5
  do {
    cp = cp->p_next;
 8002766:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8002768:	689a      	ldr	r2, [r3, #8]
 800276a:	4291      	cmp	r1, r2
 800276c:	d9fb      	bls.n	8002766 <chThdCreateStatic.constprop.44+0x76>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800276e:	685a      	ldr	r2, [r3, #4]
 8002770:	6072      	str	r2, [r6, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8002772:	2701      	movs	r7, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8002774:	6033      	str	r3, [r6, #0]
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8002776:	4631      	mov	r1, r6
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8002778:	6016      	str	r6, [r2, #0]
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 800277a:	4620      	mov	r0, r4
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
 800277c:	605e      	str	r6, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800277e:	7727      	strb	r7, [r4, #28]
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 8002780:	61ac      	str	r4, [r5, #24]
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8002782:	f7fd fd95 	bl	80002b0 <_port_switch>
 8002786:	e7e7      	b.n	8002758 <chThdCreateStatic.constprop.44+0x68>
 8002788:	20001178 	.word	0x20001178
 800278c:	080002c9 	.word	0x080002c9

08002790 <chTMStartMeasurementX.constprop.42>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8002790:	4b01      	ldr	r3, [pc, #4]	; (8002798 <chTMStartMeasurementX.constprop.42+0x8>)
 8002792:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8002794:	6083      	str	r3, [r0, #8]
 8002796:	4770      	bx	lr
 8002798:	e0001000 	.word	0xe0001000
 800279c:	00000000 	.word	0x00000000

080027a0 <chMtxLockS.constprop.38>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80027a0:	b538      	push	{r3, r4, r5, lr}

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 80027a2:	4b31      	ldr	r3, [pc, #196]	; (8002868 <chMtxLockS.constprop.38+0xc8>)
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 80027a4:	4a31      	ldr	r2, [pc, #196]	; (800286c <chMtxLockS.constprop.38+0xcc>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 80027a6:	6958      	ldr	r0, [r3, #20]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 80027a8:	6994      	ldr	r4, [r2, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 80027aa:	2800      	cmp	r0, #0
 80027ac:	d054      	beq.n	8002858 <chMtxLockS.constprop.38+0xb8>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 80027ae:	68a2      	ldr	r2, [r4, #8]
 80027b0:	6883      	ldr	r3, [r0, #8]
 80027b2:	429a      	cmp	r2, r3
 80027b4:	d906      	bls.n	80027c4 <chMtxLockS.constprop.38+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 80027b6:	7f03      	ldrb	r3, [r0, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 80027b8:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 80027ba:	2b06      	cmp	r3, #6
 80027bc:	d033      	beq.n	8002826 <chMtxLockS.constprop.38+0x86>
 80027be:	2b07      	cmp	r3, #7
 80027c0:	d01d      	beq.n	80027fe <chMtxLockS.constprop.38+0x5e>
 80027c2:	b1a3      	cbz	r3, 80027ee <chMtxLockS.constprop.38+0x4e>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80027c4:	4d2a      	ldr	r5, [pc, #168]	; (8002870 <chMtxLockS.constprop.38+0xd0>)
 80027c6:	462b      	mov	r3, r5
 80027c8:	e003      	b.n	80027d2 <chMtxLockS.constprop.38+0x32>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80027ca:	6899      	ldr	r1, [r3, #8]
 80027cc:	68a2      	ldr	r2, [r4, #8]
 80027ce:	4291      	cmp	r1, r2
 80027d0:	d302      	bcc.n	80027d8 <chMtxLockS.constprop.38+0x38>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 80027d2:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80027d4:	42ab      	cmp	r3, r5
 80027d6:	d1f8      	bne.n	80027ca <chMtxLockS.constprop.38+0x2a>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80027d8:	685a      	ldr	r2, [r3, #4]
 80027da:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 80027dc:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80027de:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 80027e0:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 80027e2:	6225      	str	r5, [r4, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 80027e4:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 80027e6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 80027ea:	f7fe ba21 	b.w	8000c30 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80027ee:	e890 000c 	ldmia.w	r0, {r2, r3}
 80027f2:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80027f4:	6802      	ldr	r2, [r0, #0]
 80027f6:	6053      	str	r3, [r2, #4]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 80027f8:	f7fe fc0a 	bl	8001010 <chSchReadyI>
 80027fc:	e7e2      	b.n	80027c4 <chMtxLockS.constprop.38+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80027fe:	e890 000a 	ldmia.w	r0, {r1, r3}
 8002802:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8002804:	6801      	ldr	r1, [r0, #0]
 8002806:	604b      	str	r3, [r1, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8002808:	6a05      	ldr	r5, [r0, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800280a:	462b      	mov	r3, r5
 800280c:	e002      	b.n	8002814 <chMtxLockS.constprop.38+0x74>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800280e:	6899      	ldr	r1, [r3, #8]
 8002810:	4291      	cmp	r1, r2
 8002812:	d302      	bcc.n	800281a <chMtxLockS.constprop.38+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8002814:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8002816:	429d      	cmp	r5, r3
 8002818:	d1f9      	bne.n	800280e <chMtxLockS.constprop.38+0x6e>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800281a:	685a      	ldr	r2, [r3, #4]
 800281c:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800281e:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8002820:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 8002822:	6058      	str	r0, [r3, #4]
 8002824:	e7ce      	b.n	80027c4 <chMtxLockS.constprop.38+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8002826:	e890 000a 	ldmia.w	r0, {r1, r3}
 800282a:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800282c:	6801      	ldr	r1, [r0, #0]
 800282e:	604b      	str	r3, [r1, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8002830:	6a05      	ldr	r5, [r0, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8002832:	462b      	mov	r3, r5
 8002834:	e002      	b.n	800283c <chMtxLockS.constprop.38+0x9c>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8002836:	6899      	ldr	r1, [r3, #8]
 8002838:	4291      	cmp	r1, r2
 800283a:	d302      	bcc.n	8002842 <chMtxLockS.constprop.38+0xa2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800283c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800283e:	429d      	cmp	r5, r3
 8002840:	d1f9      	bne.n	8002836 <chMtxLockS.constprop.38+0x96>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8002842:	685a      	ldr	r2, [r3, #4]
 8002844:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8002846:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8002848:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 800284a:	6058      	str	r0, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 800284c:	68a8      	ldr	r0, [r5, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800284e:	68a2      	ldr	r2, [r4, #8]
 8002850:	6883      	ldr	r3, [r0, #8]
 8002852:	429a      	cmp	r2, r3
 8002854:	d8af      	bhi.n	80027b6 <chMtxLockS.constprop.38+0x16>
 8002856:	e7b5      	b.n	80027c4 <chMtxLockS.constprop.38+0x24>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 8002858:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 800285a:	615c      	str	r4, [r3, #20]
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 800285c:	f103 020c 	add.w	r2, r3, #12

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 8002860:	6199      	str	r1, [r3, #24]
    ctp->p_mtxlist = mp;
 8002862:	63a2      	str	r2, [r4, #56]	; 0x38
 8002864:	bd38      	pop	{r3, r4, r5, pc}
 8002866:	bf00      	nop
 8002868:	20001354 	.word	0x20001354
 800286c:	20001178 	.word	0x20001178
 8002870:	20001360 	.word	0x20001360
	...

08002880 <chMtxUnlock.constprop.36>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002880:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8002882:	4f1b      	ldr	r7, [pc, #108]	; (80028f0 <chMtxUnlock.constprop.36+0x70>)
 8002884:	2320      	movs	r3, #32
 8002886:	69b8      	ldr	r0, [r7, #24]
 8002888:	f383 8811 	msr	BASEPRI, r3
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800288c:	4d19      	ldr	r5, [pc, #100]	; (80028f4 <chMtxUnlock.constprop.36+0x74>)
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800288e:	462e      	mov	r6, r5
 8002890:	69ab      	ldr	r3, [r5, #24]
 8002892:	f856 4f0c 	ldr.w	r4, [r6, #12]!
 8002896:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002898:	42b4      	cmp	r4, r6
 800289a:	d022      	beq.n	80028e2 <chMtxUnlock.constprop.36+0x62>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 800289c:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800289e:	b14b      	cbz	r3, 80028b4 <chMtxUnlock.constprop.36+0x34>
 80028a0:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80028a2:	4293      	cmp	r3, r2
 80028a4:	d003      	beq.n	80028ae <chMtxUnlock.constprop.36+0x2e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 80028a6:	6892      	ldr	r2, [r2, #8]
 80028a8:	4291      	cmp	r1, r2
 80028aa:	bf38      	it	cc
 80028ac:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 80028ae:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80028b0:	2b00      	cmp	r3, #0
 80028b2:	d1f5      	bne.n	80028a0 <chMtxUnlock.constprop.36+0x20>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80028b4:	6823      	ldr	r3, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 80028b6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 80028b8:	6081      	str	r1, [r0, #8]
 80028ba:	60eb      	str	r3, [r5, #12]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80028bc:	4620      	mov	r0, r4
  tqp->p_next->p_prev = (thread_t *)tqp;
 80028be:	605e      	str	r6, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 80028c0:	61aa      	str	r2, [r5, #24]
      tp->p_mtxlist = mp;
 80028c2:	63a6      	str	r6, [r4, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 80028c4:	616c      	str	r4, [r5, #20]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80028c6:	f7fe fba3 	bl	8001010 <chSchReadyI>
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 80028ca:	683a      	ldr	r2, [r7, #0]
 80028cc:	69bb      	ldr	r3, [r7, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 80028ce:	6892      	ldr	r2, [r2, #8]
 80028d0:	689b      	ldr	r3, [r3, #8]
 80028d2:	429a      	cmp	r2, r3
 80028d4:	d901      	bls.n	80028da <chMtxUnlock.constprop.36+0x5a>
    chSchDoRescheduleAhead();
 80028d6:	f7fe f983 	bl	8000be0 <chSchDoRescheduleAhead>
 80028da:	2300      	movs	r3, #0
 80028dc:	f383 8811 	msr	BASEPRI, r3
 80028e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      chSchRescheduleS();
    }
    else {
      mp->m_owner = NULL;
 80028e2:	2300      	movs	r3, #0
 80028e4:	616b      	str	r3, [r5, #20]
 80028e6:	2300      	movs	r3, #0
 80028e8:	f383 8811 	msr	BASEPRI, r3
 80028ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80028ee:	bf00      	nop
 80028f0:	20001178 	.word	0x20001178
 80028f4:	20001354 	.word	0x20001354
	...

08002900 <chEvtBroadcastFlagsI.constprop.35>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8002900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8002902:	4f17      	ldr	r7, [pc, #92]	; (8002960 <chEvtBroadcastFlagsI.constprop.35+0x60>)
 8002904:	f857 4f04 	ldr.w	r4, [r7, #4]!
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8002908:	42bc      	cmp	r4, r7
 800290a:	d020      	beq.n	800294e <chEvtBroadcastFlagsI.constprop.35+0x4e>
 800290c:	4605      	mov	r5, r0
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800290e:	2600      	movs	r6, #0
 8002910:	e002      	b.n	8002918 <chEvtBroadcastFlagsI.constprop.35+0x18>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8002912:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8002914:	42bc      	cmp	r4, r7
 8002916:	d01a      	beq.n	800294e <chEvtBroadcastFlagsI.constprop.35+0x4e>
  /*lint -restore*/
    elp->el_flags |= flags;
 8002918:	68e3      	ldr	r3, [r4, #12]
 800291a:	432b      	orrs	r3, r5
 800291c:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800291e:	b115      	cbz	r5, 8002926 <chEvtBroadcastFlagsI.constprop.35+0x26>
 8002920:	6922      	ldr	r2, [r4, #16]
 8002922:	4213      	tst	r3, r2
 8002924:	d0f5      	beq.n	8002912 <chEvtBroadcastFlagsI.constprop.35+0x12>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8002926:	6860      	ldr	r0, [r4, #4]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002928:	68a1      	ldr	r1, [r4, #8]
 800292a:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800292c:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 800292e:	430b      	orrs	r3, r1
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002930:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002932:	6343      	str	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002934:	d00c      	beq.n	8002950 <chEvtBroadcastFlagsI.constprop.35+0x50>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8002936:	2a0b      	cmp	r2, #11
 8002938:	d1eb      	bne.n	8002912 <chEvtBroadcastFlagsI.constprop.35+0x12>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 800293a:	6a02      	ldr	r2, [r0, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800293c:	ea32 0303 	bics.w	r3, r2, r3
 8002940:	d1e7      	bne.n	8002912 <chEvtBroadcastFlagsI.constprop.35+0x12>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8002942:	6206      	str	r6, [r0, #32]
    (void) chSchReadyI(tp);
 8002944:	f7fe fb64 	bl	8001010 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8002948:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800294a:	42bc      	cmp	r4, r7
 800294c:	d1e4      	bne.n	8002918 <chEvtBroadcastFlagsI.constprop.35+0x18>
 800294e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002950:	6a02      	ldr	r2, [r0, #32]
 8002952:	4213      	tst	r3, r2
 8002954:	d0dd      	beq.n	8002912 <chEvtBroadcastFlagsI.constprop.35+0x12>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8002956:	6206      	str	r6, [r0, #32]
    (void) chSchReadyI(tp);
 8002958:	f7fe fb5a 	bl	8001010 <chSchReadyI>
 800295c:	e7f4      	b.n	8002948 <chEvtBroadcastFlagsI.constprop.35+0x48>
 800295e:	bf00      	nop
 8002960:	200010f8 	.word	0x200010f8
	...

08002970 <dmaStreamAllocate.constprop.23>:
 * @retval false        no error, stream taken.
 * @retval true         error, stream already taken.
 *
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
 8002970:	b470      	push	{r4, r5, r6}
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8002972:	4d1b      	ldr	r5, [pc, #108]	; (80029e0 <dmaStreamAllocate.constprop.23+0x70>)
 8002974:	7c44      	ldrb	r4, [r0, #17]
 8002976:	682a      	ldr	r2, [r5, #0]
 8002978:	2301      	movs	r3, #1
 800297a:	fa03 f104 	lsl.w	r1, r3, r4
 800297e:	4011      	ands	r1, r2
 8002980:	d12b      	bne.n	80029da <dmaStreamAllocate.constprop.23+0x6a>
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8002982:	4b18      	ldr	r3, [pc, #96]	; (80029e4 <dmaStreamAllocate.constprop.23+0x74>)
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8002984:	4e18      	ldr	r6, [pc, #96]	; (80029e8 <dmaStreamAllocate.constprop.23+0x78>)
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8002986:	f843 1034 	str.w	r1, [r3, r4, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 800298a:	eb03 04c4 	add.w	r4, r3, r4, lsl #3

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 800298e:	0653      	lsls	r3, r2, #25
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8002990:	6066      	str	r6, [r4, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8002992:	d104      	bne.n	800299e <dmaStreamAllocate.constprop.23+0x2e>
    rccEnableDMA1(false);
 8002994:	4915      	ldr	r1, [pc, #84]	; (80029ec <dmaStreamAllocate.constprop.23+0x7c>)
 8002996:	694b      	ldr	r3, [r1, #20]
 8002998:	f043 0301 	orr.w	r3, r3, #1
 800299c:	614b      	str	r3, [r1, #20]
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 800299e:	f412 6f78 	tst.w	r2, #3968	; 0xf80
 80029a2:	d014      	beq.n	80029ce <dmaStreamAllocate.constprop.23+0x5e>
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80029a4:	6841      	ldr	r1, [r0, #4]
 80029a6:	6806      	ldr	r6, [r0, #0]
 80029a8:	680b      	ldr	r3, [r1, #0]
 80029aa:	f023 030f 	bic.w	r3, r3, #15
 80029ae:	600b      	str	r3, [r1, #0]
 80029b0:	7c04      	ldrb	r4, [r0, #16]
 80029b2:	230e      	movs	r3, #14
 80029b4:	fa03 f404 	lsl.w	r4, r3, r4
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80029b8:	2300      	movs	r3, #0
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80029ba:	6074      	str	r4, [r6, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80029bc:	600b      	str	r3, [r1, #0]
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 80029be:	7c40      	ldrb	r0, [r0, #17]
 80029c0:	2101      	movs	r1, #1
 80029c2:	4081      	lsls	r1, r0
 80029c4:	430a      	orrs	r2, r1

  return false;
 80029c6:	4618      	mov	r0, r3
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 80029c8:	602a      	str	r2, [r5, #0]

  return false;
}
 80029ca:	bc70      	pop	{r4, r5, r6}
 80029cc:	4770      	bx	lr
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
    rccEnableDMA1(false);
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
    rccEnableDMA2(false);
 80029ce:	4907      	ldr	r1, [pc, #28]	; (80029ec <dmaStreamAllocate.constprop.23+0x7c>)
 80029d0:	694b      	ldr	r3, [r1, #20]
 80029d2:	f043 0302 	orr.w	r3, r3, #2
 80029d6:	614b      	str	r3, [r1, #20]
 80029d8:	e7e4      	b.n	80029a4 <dmaStreamAllocate.constprop.23+0x34>

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;
 80029da:	4618      	mov	r0, r3
 80029dc:	e7f5      	b.n	80029ca <dmaStreamAllocate.constprop.23+0x5a>
 80029de:	bf00      	nop
 80029e0:	20001350 	.word	0x20001350
 80029e4:	20001098 	.word	0x20001098
 80029e8:	20001354 	.word	0x20001354
 80029ec:	40021000 	.word	0x40021000

080029f0 <i2c_lld_master_transmit_timeout.constprop.20>:
 *                      timeout the driver must be stopped and restarted
 *                      because the bus is in an uncertain state</b>.
 *
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
 80029f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
  msg_t msg;
  I2C_TypeDef *dp = i2cp->i2c;
 80029f4:	4f3d      	ldr	r7, [pc, #244]	; (8002aec <i2c_lld_master_transmit_timeout.constprop.20+0xfc>)
  systime_t start, end;

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 80029f6:	2400      	movs	r4, #0
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
  msg_t msg;
  I2C_TypeDef *dp = i2cp->i2c;
 80029f8:	6b3d      	ldr	r5, [r7, #48]	; 0x30
  systime_t start, end;

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 80029fa:	60bc      	str	r4, [r7, #8]
 *                      timeout the driver must be stopped and restarted
 *                      because the bus is in an uncertain state</b>.
 *
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
 80029fc:	4686      	mov	lr, r0
 80029fe:	f384 8811 	msr	BASEPRI, r4
  /* Releases the lock from high level driver.*/
  osalSysUnlock();

#if STM32_I2C_USE_DMA == TRUE
  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8002a02:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 8002a04:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8002a06:	f8d6 c004 	ldr.w	ip, [r6, #4]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup, note, rxbytes can be zero but we write the value anyway.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8002a0a:	6abe      	ldr	r6, [r7, #40]	; 0x28
 8002a0c:	f8d7 8020 	ldr.w	r8, [r7, #32]
 8002a10:	6876      	ldr	r6, [r6, #4]
  /* Releases the lock from high level driver.*/
  osalSysUnlock();

#if STM32_I2C_USE_DMA == TRUE
  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8002a12:	f8cc 0000 	str.w	r0, [ip]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 8002a16:	f8cc 100c 	str.w	r1, [ip, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8002a1a:	f8cc 2004 	str.w	r2, [ip, #4]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8002a1e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000

  /* RX DMA setup, note, rxbytes can be zero but we write the value anyway.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8002a22:	f8c6 8000 	str.w	r8, [r6]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8002a26:	60f3      	str	r3, [r6, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8002a28:	9b06      	ldr	r3, [sp, #24]
 8002a2a:	6073      	str	r3, [r6, #4]
 8002a2c:	6a4e      	ldr	r6, [r1, #36]	; 0x24
 8002a2e:	2320      	movs	r3, #32
 8002a30:	f383 8811 	msr	BASEPRI, r3
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
 8002a34:	69aa      	ldr	r2, [r5, #24]
 8002a36:	0412      	lsls	r2, r2, #16
 8002a38:	d513      	bpl.n	8002a62 <i2c_lld_master_transmit_timeout.constprop.20+0x72>
 8002a3a:	6a4a      	ldr	r2, [r1, #36]	; 0x24
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end)) {
 8002a3c:	1b92      	subs	r2, r2, r6
 8002a3e:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
 8002a42:	d24f      	bcs.n	8002ae4 <i2c_lld_master_transmit_timeout.constprop.20+0xf4>
 8002a44:	4622      	mov	r2, r4
 8002a46:	461c      	mov	r4, r3
 8002a48:	e004      	b.n	8002a54 <i2c_lld_master_transmit_timeout.constprop.20+0x64>
 8002a4a:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8002a4c:	1b9b      	subs	r3, r3, r6
 8002a4e:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8002a52:	d247      	bcs.n	8002ae4 <i2c_lld_master_transmit_timeout.constprop.20+0xf4>
 8002a54:	f382 8811 	msr	BASEPRI, r2
 8002a58:	f384 8811 	msr	BASEPRI, r4
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
 8002a5c:	69ab      	ldr	r3, [r5, #24]
 8002a5e:	0418      	lsls	r0, r3, #16
 8002a60:	d4f3      	bmi.n	8002a4a <i2c_lld_master_transmit_timeout.constprop.20+0x5a>
 */
static void i2c_lld_set_address(I2CDriver *i2cp, i2caddr_t addr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 8002a62:	687b      	ldr	r3, [r7, #4]
 8002a64:	6b3e      	ldr	r6, [r7, #48]	; 0x30
 8002a66:	6899      	ldr	r1, [r3, #8]
 8002a68:	050c      	lsls	r4, r1, #20
 8002a6a:	d537      	bpl.n	8002adc <i2c_lld_master_transmit_timeout.constprop.20+0xec>
    dp->CR2 = (uint32_t)addr << 1U;
  else
    dp->CR2 = (uint32_t)addr;
 8002a6c:	f8c6 e004 	str.w	lr, [r6, #4]
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 8002a70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002a72:	4c1f      	ldr	r4, [pc, #124]	; (8002af0 <i2c_lld_master_transmit_timeout.constprop.20+0x100>)
 8002a74:	6858      	ldr	r0, [r3, #4]
 8002a76:	6843      	ldr	r3, [r0, #4]
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8002a78:	6872      	ldr	r2, [r6, #4]
            (n << 16U) | reload;
 8002a7a:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
 8002a7e:	2bff      	cmp	r3, #255	; 0xff
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            (n << 16U) | reload;
 8002a80:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
  }
  else {
    reload = 0U;
 8002a84:	bf94      	ite	ls
 8002a86:	f04f 0e00 	movls.w	lr, #0

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8002a8a:	f04f 7e80 	movhi.w	lr, #16777216	; 0x1000000
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            (n << 16U) | reload;
 8002a8e:	ea42 0201 	orr.w	r2, r2, r1
 8002a92:	bf94      	ite	ls
 8002a94:	041b      	lslls	r3, r3, #16
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
 8002a96:	f44f 037f 	movhi.w	r3, #16711680	; 0xff0000
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            (n << 16U) | reload;
 8002a9a:	ea42 020e 	orr.w	r2, r2, lr
 8002a9e:	4313      	orrs	r3, r2
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8002aa0:	6073      	str	r3, [r6, #4]
  /* Preparing the transfer.*/
  i2c_lld_setup_tx_transfer(i2cp);

#if STM32_I2C_USE_DMA == TRUE
  /* Enabling TX DMA.*/
  dmaStreamEnable(i2cp->dmatx);
 8002aa2:	6803      	ldr	r3, [r0, #0]
 8002aa4:	69a2      	ldr	r2, [r4, #24]
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->p_u.wttrp = trp;
 8002aa6:	4913      	ldr	r1, [pc, #76]	; (8002af4 <i2c_lld_master_transmit_timeout.constprop.20+0x104>)
 8002aa8:	f043 0301 	orr.w	r3, r3, #1
 8002aac:	6003      	str	r3, [r0, #0]

  /* Transfer complete interrupt enabled.*/
  dp->CR1 |= I2C_CR1_TCIE;
 8002aae:	682b      	ldr	r3, [r5, #0]
 8002ab0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002ab4:	602b      	str	r3, [r5, #0]
  /* Transfer complete and TX interrupts enabled.*/
  dp->CR1 |= I2C_CR1_TCIE | I2C_CR1_TXIE;
#endif

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_START;
 8002ab6:	686b      	ldr	r3, [r5, #4]
 8002ab8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8002abc:	606b      	str	r3, [r5, #4]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8002abe:	2003      	movs	r0, #3
 8002ac0:	6211      	str	r1, [r2, #32]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8002ac2:	61fa      	str	r2, [r7, #28]
 8002ac4:	f7fe f8b4 	bl	8000c30 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8002ac8:	69a3      	ldr	r3, [r4, #24]
 8002aca:	6a18      	ldr	r0, [r3, #32]
  /* Waits for the operation completion or a timeout.*/
  msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);

  /* In case of a software timeout a STOP is sent as an extreme attempt
     to release the bus.*/
  if (msg == MSG_TIMEOUT) {
 8002acc:	1c43      	adds	r3, r0, #1
 8002ace:	d103      	bne.n	8002ad8 <i2c_lld_master_transmit_timeout.constprop.20+0xe8>
    dp->CR2 |= I2C_CR2_STOP;
 8002ad0:	686b      	ldr	r3, [r5, #4]
 8002ad2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002ad6:	606b      	str	r3, [r5, #4]
  }

  return msg;
}
 8002ad8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
static void i2c_lld_set_address(I2CDriver *i2cp, i2caddr_t addr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
    dp->CR2 = (uint32_t)addr << 1U;
 8002adc:	ea4f 004e 	mov.w	r0, lr, lsl #1
 8002ae0:	6070      	str	r0, [r6, #4]
 8002ae2:	e7c5      	b.n	8002a70 <i2c_lld_master_transmit_timeout.constprop.20+0x80>
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end)) {
      return MSG_TIMEOUT;
 8002ae4:	f04f 30ff 	mov.w	r0, #4294967295
 8002ae8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002aec:	20001354 	.word	0x20001354
 8002af0:	20001178 	.word	0x20001178
 8002af4:	20001370 	.word	0x20001370
	...

08002b00 <usb_lld_start_in.constprop.10>:
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8002b00:	68c3      	ldr	r3, [r0, #12]
 8002b02:	6958      	ldr	r0, [r3, #20]

  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
 8002b04:	8a1b      	ldrh	r3, [r3, #16]
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  /* Transfer initialization.*/
  n = isp->txsize;
 8002b06:	6802      	ldr	r2, [r0, #0]
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
  usb_packet_write_from_buffer(ep, isp->txbuf, n);
 8002b08:	6881      	ldr	r1, [r0, #8]
 8002b0a:	429a      	cmp	r2, r3
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8002b0c:	b410      	push	{r4}
 8002b0e:	bf28      	it	cs
 8002b10:	461a      	movcs	r2, r3
 * @notapi
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002b12:	4c16      	ldr	r4, [pc, #88]	; (8002b6c <usb_lld_start_in.constprop.10+0x6c>)
  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
 8002b14:	60c2      	str	r2, [r0, #12]
 * @notapi
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002b16:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8002b18:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8002b1c:	f500 40c0 	add.w	r0, r0, #24576	; 0x6000
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8002b20:	6803      	ldr	r3, [r0, #0]
  if (EPR_EP_TYPE_IS_ISO(epr) && (epr & EPR_DTOG_TX))
    udp->TXCOUNT1 = (stm32_usb_pma_t)n;
  else
    udp->TXCOUNT0 = (stm32_usb_pma_t)n;
#else
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 8002b22:	6042      	str	r2, [r0, #4]
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 8002b24:	b18a      	cbz	r2, 8002b4a <usb_lld_start_in.constprop.10+0x4a>
 8002b26:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 8002b2a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8002b2e:	005b      	lsls	r3, r3, #1
 8002b30:	3a01      	subs	r2, #1
 8002b32:	0852      	lsrs	r2, r2, #1
 8002b34:	3304      	adds	r3, #4
 8002b36:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8002b3a:	e000      	b.n	8002b3e <usb_lld_start_in.constprop.10+0x3e>
 8002b3c:	3304      	adds	r3, #4
    uint32_t w;

    w  = *buf++;
    w |= *buf++ << 8;
 8002b3e:	f831 0b02 	ldrh.w	r0, [r1], #2
    *pmap++ = (stm32_usb_pma_t)w;
 8002b42:	f843 0c04 	str.w	r0, [r3, #-4]
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 8002b46:	429a      	cmp	r2, r3
 8002b48:	d1f8      	bne.n	8002b3c <usb_lld_start_in.constprop.10+0x3c>
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
  usb_packet_write_from_buffer(ep, isp->txbuf, n);

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8002b4a:	4a08      	ldr	r2, [pc, #32]	; (8002b6c <usb_lld_start_in.constprop.10+0x6c>)
}
 8002b4c:	f85d 4b04 	ldr.w	r4, [sp], #4
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
  usb_packet_write_from_buffer(ep, isp->txbuf, n);

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8002b50:	6813      	ldr	r3, [r2, #0]
 8002b52:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8002b56:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002b5a:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8002b5e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002b62:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002b66:	6013      	str	r3, [r2, #0]
}
 8002b68:	4770      	bx	lr
 8002b6a:	bf00      	nop
 8002b6c:	40005c00 	.word	0x40005c00

08002b70 <usb_lld_start_out.constprop.9>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8002b70:	68c1      	ldr	r1, [r0, #12]
 8002b72:	698a      	ldr	r2, [r1, #24]

  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
 8002b74:	6813      	ldr	r3, [r2, #0]
 8002b76:	b19b      	cbz	r3, 8002ba0 <usb_lld_start_out.constprop.9+0x30>
    osp->rxpkts = 1;
  else
    osp->rxpkts = (uint16_t)((osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8002b78:	8a49      	ldrh	r1, [r1, #18]
 8002b7a:	3b01      	subs	r3, #1
 8002b7c:	440b      	add	r3, r1
 8002b7e:	fbb3 f3f1 	udiv	r3, r3, r1
 8002b82:	8193      	strh	r3, [r2, #12]
                             usbp->epc[ep]->out_maxsize);

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 8002b84:	4a08      	ldr	r2, [pc, #32]	; (8002ba8 <usb_lld_start_out.constprop.9+0x38>)
 8002b86:	6813      	ldr	r3, [r2, #0]
 8002b88:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8002b8c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002b90:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8002b94:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002b98:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002b9c:	6013      	str	r3, [r2, #0]
 8002b9e:	4770      	bx	lr
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
    osp->rxpkts = 1;
 8002ba0:	2301      	movs	r3, #1
 8002ba2:	8193      	strh	r3, [r2, #12]
 8002ba4:	e7ee      	b.n	8002b84 <usb_lld_start_out.constprop.9+0x14>
 8002ba6:	bf00      	nop
 8002ba8:	40005c00 	.word	0x40005c00
 8002bac:	00000000 	.word	0x00000000

08002bb0 <zero_status>:
	...

08002bc0 <active_status>:
	...

08002bd0 <ram_areas>:
 8002bd0:	08002ddc 20001388 20001388 20001388     .-..... ... ... 
 8002be0:	08002ddc 00000000 00000000 00000000     .-..............
 8002bf0:	08002ddc 00000000 00000000 00000000     .-..............
 8002c00:	08002ddc 00000000 00000000 00000000     .-..............
 8002c10:	08002ddc 10000000 10000000 10000000     .-..............
 8002c20:	08002ddc 00000000 00000000 00000000     .-..............
 8002c30:	08002ddc 00000000 00000000 00000000     .-..............
 8002c40:	08002ddc 00000000 00000000 00000000     .-..............

08002c50 <halted_status>:
 8002c50:	00000001 00000000 00000000 00000000     ................

08002c60 <ep0config>:
 8002c60:	00000000 08000591 080004a1 080003f1     ................
 8002c70:	00400040 20000808 20000808 00000001     @.@.... ... ....
 8002c80:	20000818 00000000 00000000 00000000     ... ............

08002c90 <ch_debug>:
 8002c90:	6e69616d 18451600 08440404 1814100c     main..E...D.....
 8002ca0:	1e1d1c00 00000000 00000000 00000000     ................

08002cb0 <vmt>:
 8002cb0:	08000e51 08000f71 08000ed1 08000fe1     Q...q...........
 8002cc0:	08000ec1 08000fd1 08000e41 08000f61     ........A...a...

08002cd0 <i2cconfig>:
 8002cd0:	00902025 00000000 00000000 00000000     % ..............

08002ce0 <_stm32_dma_streams>:
 8002ce0:	40020000 40020008 00000001 00000000     ...@...@........
 8002cf0:	000b0000 40020000 4002001c 00000002     .......@...@....
 8002d00:	00000000 000c0104 40020000 40020030     ...........@0..@
 8002d10:	00000004 00000000 000d0208 40020000     ...............@
 8002d20:	40020044 00000008 00000000 000e030c     D..@............
 8002d30:	40020000 40020058 00000010 00000000     ...@X..@........
 8002d40:	000f0410 40020000 4002006c 00000020     .......@l..@ ...
 8002d50:	00000000 00100514 40020000 40020080     ...........@...@
 8002d60:	00000040 00000000 00110618 40020400     @..............@
 8002d70:	40020408 00000080 00000000 00380700     ...@..........8.
 8002d80:	40020400 4002041c 00000100 00000000     ...@...@........
 8002d90:	00390804 40020400 40020430 00000200     ..9....@0..@....
 8002da0:	00000000 003a0908 40020400 40020444     ......:....@D..@
 8002db0:	00000400 00000000 003b0a0c 40020400     ..........;....@
 8002dc0:	40020458 00000800 00000000 003c0b10     X..@..........<.
 8002dd0:	656c6469 00000000                       idle....
